// Code generated by counterfeiter. DO NOT EDIT.
package dockerfakes

import (
	"context"
	"io"
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/image"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/api/types/registry"
	"github.com/docker/docker/api/types/volume"
	v1 "github.com/opencontainers/image-spec/specs-go/v1"
	"github.com/rkoster/instant-bosh/internal/docker"
)

type FakeDockerAPI struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerCreateStub        func(context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, *v1.Platform, string) (container.CreateResponse, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		arg1 context.Context
		arg2 *container.Config
		arg3 *container.HostConfig
		arg4 *network.NetworkingConfig
		arg5 *v1.Platform
		arg6 string
	}
	containerCreateReturns struct {
		result1 container.CreateResponse
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 container.CreateResponse
		result2 error
	}
	ContainerExecAttachStub        func(context.Context, string, container.ExecAttachOptions) (types.HijackedResponse, error)
	containerExecAttachMutex       sync.RWMutex
	containerExecAttachArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.ExecAttachOptions
	}
	containerExecAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerExecAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerExecCreateStub        func(context.Context, string, container.ExecOptions) (types.IDResponse, error)
	containerExecCreateMutex       sync.RWMutex
	containerExecCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.ExecOptions
	}
	containerExecCreateReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerExecCreateReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerExportStub        func(context.Context, string) (io.ReadCloser, error)
	containerExportMutex       sync.RWMutex
	containerExportArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerExportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerExportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerInspectStub        func(context.Context, string) (types.ContainerJSON, error)
	containerInspectMutex       sync.RWMutex
	containerInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerInspectReturns struct {
		result1 types.ContainerJSON
		result2 error
	}
	containerInspectReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 error
	}
	ContainerListStub        func(context.Context, container.ListOptions) ([]types.Container, error)
	containerListMutex       sync.RWMutex
	containerListArgsForCall []struct {
		arg1 context.Context
		arg2 container.ListOptions
	}
	containerListReturns struct {
		result1 []types.Container
		result2 error
	}
	containerListReturnsOnCall map[int]struct {
		result1 []types.Container
		result2 error
	}
	ContainerLogsStub        func(context.Context, string, container.LogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.LogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerRemoveStub        func(context.Context, string, container.RemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.RemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	containerRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStartStub        func(context.Context, string, container.StartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.StartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStopStub        func(context.Context, string, container.StopOptions) error
	containerStopMutex       sync.RWMutex
	containerStopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.StopOptions
	}
	containerStopReturns struct {
		result1 error
	}
	containerStopReturnsOnCall map[int]struct {
		result1 error
	}
	DaemonHostStub        func() string
	daemonHostMutex       sync.RWMutex
	daemonHostArgsForCall []struct {
	}
	daemonHostReturns struct {
		result1 string
	}
	daemonHostReturnsOnCall map[int]struct {
		result1 string
	}
	DistributionInspectStub        func(context.Context, string, string) (registry.DistributionInspect, error)
	distributionInspectMutex       sync.RWMutex
	distributionInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	distributionInspectReturns struct {
		result1 registry.DistributionInspect
		result2 error
	}
	distributionInspectReturnsOnCall map[int]struct {
		result1 registry.DistributionInspect
		result2 error
	}
	ImageInspectWithRawStub        func(context.Context, string) (types.ImageInspect, []byte, error)
	imageInspectWithRawMutex       sync.RWMutex
	imageInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	imageInspectWithRawReturns struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	imageInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	ImagePullStub        func(context.Context, string, image.PullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 image.PullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePullReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	NetworkCreateStub        func(context.Context, string, network.CreateOptions) (network.CreateResponse, error)
	networkCreateMutex       sync.RWMutex
	networkCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 network.CreateOptions
	}
	networkCreateReturns struct {
		result1 network.CreateResponse
		result2 error
	}
	networkCreateReturnsOnCall map[int]struct {
		result1 network.CreateResponse
		result2 error
	}
	NetworkInspectStub        func(context.Context, string, network.InspectOptions) (network.Inspect, error)
	networkInspectMutex       sync.RWMutex
	networkInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 network.InspectOptions
	}
	networkInspectReturns struct {
		result1 network.Inspect
		result2 error
	}
	networkInspectReturnsOnCall map[int]struct {
		result1 network.Inspect
		result2 error
	}
	NetworkRemoveStub        func(context.Context, string) error
	networkRemoveMutex       sync.RWMutex
	networkRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	networkRemoveReturns struct {
		result1 error
	}
	networkRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	VolumeCreateStub        func(context.Context, volume.CreateOptions) (volume.Volume, error)
	volumeCreateMutex       sync.RWMutex
	volumeCreateArgsForCall []struct {
		arg1 context.Context
		arg2 volume.CreateOptions
	}
	volumeCreateReturns struct {
		result1 volume.Volume
		result2 error
	}
	volumeCreateReturnsOnCall map[int]struct {
		result1 volume.Volume
		result2 error
	}
	VolumeInspectStub        func(context.Context, string) (volume.Volume, error)
	volumeInspectMutex       sync.RWMutex
	volumeInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	volumeInspectReturns struct {
		result1 volume.Volume
		result2 error
	}
	volumeInspectReturnsOnCall map[int]struct {
		result1 volume.Volume
		result2 error
	}
	VolumeRemoveStub        func(context.Context, string, bool) error
	volumeRemoveMutex       sync.RWMutex
	volumeRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}
	volumeRemoveReturns struct {
		result1 error
	}
	volumeRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDockerAPI) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeDockerAPI) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeDockerAPI) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) ContainerCreate(arg1 context.Context, arg2 *container.Config, arg3 *container.HostConfig, arg4 *network.NetworkingConfig, arg5 *v1.Platform, arg6 string) (container.CreateResponse, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		arg1 context.Context
		arg2 *container.Config
		arg3 *container.HostConfig
		arg4 *network.NetworkingConfig
		arg5 *v1.Platform
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.ContainerCreateStub
	fakeReturns := fake.containerCreateReturns
	fake.recordInvocation("ContainerCreate", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.containerCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *FakeDockerAPI) ContainerCreateCalls(stub func(context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, *v1.Platform, string) (container.CreateResponse, error)) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = stub
}

func (fake *FakeDockerAPI) ContainerCreateArgsForCall(i int) (context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, *v1.Platform, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	argsForCall := fake.containerCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeDockerAPI) ContainerCreateReturns(result1 container.CreateResponse, result2 error) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 container.CreateResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerCreateReturnsOnCall(i int, result1 container.CreateResponse, result2 error) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 container.CreateResponse
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 container.CreateResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerExecAttach(arg1 context.Context, arg2 string, arg3 container.ExecAttachOptions) (types.HijackedResponse, error) {
	fake.containerExecAttachMutex.Lock()
	ret, specificReturn := fake.containerExecAttachReturnsOnCall[len(fake.containerExecAttachArgsForCall)]
	fake.containerExecAttachArgsForCall = append(fake.containerExecAttachArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.ExecAttachOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerExecAttachStub
	fakeReturns := fake.containerExecAttachReturns
	fake.recordInvocation("ContainerExecAttach", []interface{}{arg1, arg2, arg3})
	fake.containerExecAttachMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerExecAttachCallCount() int {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	return len(fake.containerExecAttachArgsForCall)
}

func (fake *FakeDockerAPI) ContainerExecAttachCalls(stub func(context.Context, string, container.ExecAttachOptions) (types.HijackedResponse, error)) {
	fake.containerExecAttachMutex.Lock()
	defer fake.containerExecAttachMutex.Unlock()
	fake.ContainerExecAttachStub = stub
}

func (fake *FakeDockerAPI) ContainerExecAttachArgsForCall(i int) (context.Context, string, container.ExecAttachOptions) {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	argsForCall := fake.containerExecAttachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ContainerExecAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.containerExecAttachMutex.Lock()
	defer fake.containerExecAttachMutex.Unlock()
	fake.ContainerExecAttachStub = nil
	fake.containerExecAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerExecAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.containerExecAttachMutex.Lock()
	defer fake.containerExecAttachMutex.Unlock()
	fake.ContainerExecAttachStub = nil
	if fake.containerExecAttachReturnsOnCall == nil {
		fake.containerExecAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerExecAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerExecCreate(arg1 context.Context, arg2 string, arg3 container.ExecOptions) (types.IDResponse, error) {
	fake.containerExecCreateMutex.Lock()
	ret, specificReturn := fake.containerExecCreateReturnsOnCall[len(fake.containerExecCreateArgsForCall)]
	fake.containerExecCreateArgsForCall = append(fake.containerExecCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.ExecOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerExecCreateStub
	fakeReturns := fake.containerExecCreateReturns
	fake.recordInvocation("ContainerExecCreate", []interface{}{arg1, arg2, arg3})
	fake.containerExecCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerExecCreateCallCount() int {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	return len(fake.containerExecCreateArgsForCall)
}

func (fake *FakeDockerAPI) ContainerExecCreateCalls(stub func(context.Context, string, container.ExecOptions) (types.IDResponse, error)) {
	fake.containerExecCreateMutex.Lock()
	defer fake.containerExecCreateMutex.Unlock()
	fake.ContainerExecCreateStub = stub
}

func (fake *FakeDockerAPI) ContainerExecCreateArgsForCall(i int) (context.Context, string, container.ExecOptions) {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	argsForCall := fake.containerExecCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ContainerExecCreateReturns(result1 types.IDResponse, result2 error) {
	fake.containerExecCreateMutex.Lock()
	defer fake.containerExecCreateMutex.Unlock()
	fake.ContainerExecCreateStub = nil
	fake.containerExecCreateReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerExecCreateReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.containerExecCreateMutex.Lock()
	defer fake.containerExecCreateMutex.Unlock()
	fake.ContainerExecCreateStub = nil
	if fake.containerExecCreateReturnsOnCall == nil {
		fake.containerExecCreateReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerExecCreateReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerExport(arg1 context.Context, arg2 string) (io.ReadCloser, error) {
	fake.containerExportMutex.Lock()
	ret, specificReturn := fake.containerExportReturnsOnCall[len(fake.containerExportArgsForCall)]
	fake.containerExportArgsForCall = append(fake.containerExportArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ContainerExportStub
	fakeReturns := fake.containerExportReturns
	fake.recordInvocation("ContainerExport", []interface{}{arg1, arg2})
	fake.containerExportMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerExportCallCount() int {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	return len(fake.containerExportArgsForCall)
}

func (fake *FakeDockerAPI) ContainerExportCalls(stub func(context.Context, string) (io.ReadCloser, error)) {
	fake.containerExportMutex.Lock()
	defer fake.containerExportMutex.Unlock()
	fake.ContainerExportStub = stub
}

func (fake *FakeDockerAPI) ContainerExportArgsForCall(i int) (context.Context, string) {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	argsForCall := fake.containerExportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) ContainerExportReturns(result1 io.ReadCloser, result2 error) {
	fake.containerExportMutex.Lock()
	defer fake.containerExportMutex.Unlock()
	fake.ContainerExportStub = nil
	fake.containerExportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerExportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.containerExportMutex.Lock()
	defer fake.containerExportMutex.Unlock()
	fake.ContainerExportStub = nil
	if fake.containerExportReturnsOnCall == nil {
		fake.containerExportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerExportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerInspect(arg1 context.Context, arg2 string) (types.ContainerJSON, error) {
	fake.containerInspectMutex.Lock()
	ret, specificReturn := fake.containerInspectReturnsOnCall[len(fake.containerInspectArgsForCall)]
	fake.containerInspectArgsForCall = append(fake.containerInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ContainerInspectStub
	fakeReturns := fake.containerInspectReturns
	fake.recordInvocation("ContainerInspect", []interface{}{arg1, arg2})
	fake.containerInspectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerInspectCallCount() int {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return len(fake.containerInspectArgsForCall)
}

func (fake *FakeDockerAPI) ContainerInspectCalls(stub func(context.Context, string) (types.ContainerJSON, error)) {
	fake.containerInspectMutex.Lock()
	defer fake.containerInspectMutex.Unlock()
	fake.ContainerInspectStub = stub
}

func (fake *FakeDockerAPI) ContainerInspectArgsForCall(i int) (context.Context, string) {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	argsForCall := fake.containerInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) ContainerInspectReturns(result1 types.ContainerJSON, result2 error) {
	fake.containerInspectMutex.Lock()
	defer fake.containerInspectMutex.Unlock()
	fake.ContainerInspectStub = nil
	fake.containerInspectReturns = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerInspectReturnsOnCall(i int, result1 types.ContainerJSON, result2 error) {
	fake.containerInspectMutex.Lock()
	defer fake.containerInspectMutex.Unlock()
	fake.ContainerInspectStub = nil
	if fake.containerInspectReturnsOnCall == nil {
		fake.containerInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 error
		})
	}
	fake.containerInspectReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerList(arg1 context.Context, arg2 container.ListOptions) ([]types.Container, error) {
	fake.containerListMutex.Lock()
	ret, specificReturn := fake.containerListReturnsOnCall[len(fake.containerListArgsForCall)]
	fake.containerListArgsForCall = append(fake.containerListArgsForCall, struct {
		arg1 context.Context
		arg2 container.ListOptions
	}{arg1, arg2})
	stub := fake.ContainerListStub
	fakeReturns := fake.containerListReturns
	fake.recordInvocation("ContainerList", []interface{}{arg1, arg2})
	fake.containerListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerListCallCount() int {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	return len(fake.containerListArgsForCall)
}

func (fake *FakeDockerAPI) ContainerListCalls(stub func(context.Context, container.ListOptions) ([]types.Container, error)) {
	fake.containerListMutex.Lock()
	defer fake.containerListMutex.Unlock()
	fake.ContainerListStub = stub
}

func (fake *FakeDockerAPI) ContainerListArgsForCall(i int) (context.Context, container.ListOptions) {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	argsForCall := fake.containerListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) ContainerListReturns(result1 []types.Container, result2 error) {
	fake.containerListMutex.Lock()
	defer fake.containerListMutex.Unlock()
	fake.ContainerListStub = nil
	fake.containerListReturns = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerListReturnsOnCall(i int, result1 []types.Container, result2 error) {
	fake.containerListMutex.Lock()
	defer fake.containerListMutex.Unlock()
	fake.ContainerListStub = nil
	if fake.containerListReturnsOnCall == nil {
		fake.containerListReturnsOnCall = make(map[int]struct {
			result1 []types.Container
			result2 error
		})
	}
	fake.containerListReturnsOnCall[i] = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerLogs(arg1 context.Context, arg2 string, arg3 container.LogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.LogsOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerLogsStub
	fakeReturns := fake.containerLogsReturns
	fake.recordInvocation("ContainerLogs", []interface{}{arg1, arg2, arg3})
	fake.containerLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *FakeDockerAPI) ContainerLogsCalls(stub func(context.Context, string, container.LogsOptions) (io.ReadCloser, error)) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = stub
}

func (fake *FakeDockerAPI) ContainerLogsArgsForCall(i int) (context.Context, string, container.LogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	argsForCall := fake.containerLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ContainerRemove(arg1 context.Context, arg2 string, arg3 container.RemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	ret, specificReturn := fake.containerRemoveReturnsOnCall[len(fake.containerRemoveArgsForCall)]
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.RemoveOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerRemoveStub
	fakeReturns := fake.containerRemoveReturns
	fake.recordInvocation("ContainerRemove", []interface{}{arg1, arg2, arg3})
	fake.containerRemoveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *FakeDockerAPI) ContainerRemoveCalls(stub func(context.Context, string, container.RemoveOptions) error) {
	fake.containerRemoveMutex.Lock()
	defer fake.containerRemoveMutex.Unlock()
	fake.ContainerRemoveStub = stub
}

func (fake *FakeDockerAPI) ContainerRemoveArgsForCall(i int) (context.Context, string, container.RemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	argsForCall := fake.containerRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ContainerRemoveReturns(result1 error) {
	fake.containerRemoveMutex.Lock()
	defer fake.containerRemoveMutex.Unlock()
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) ContainerRemoveReturnsOnCall(i int, result1 error) {
	fake.containerRemoveMutex.Lock()
	defer fake.containerRemoveMutex.Unlock()
	fake.ContainerRemoveStub = nil
	if fake.containerRemoveReturnsOnCall == nil {
		fake.containerRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) ContainerStart(arg1 context.Context, arg2 string, arg3 container.StartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.StartOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerStartStub
	fakeReturns := fake.containerStartReturns
	fake.recordInvocation("ContainerStart", []interface{}{arg1, arg2, arg3})
	fake.containerStartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *FakeDockerAPI) ContainerStartCalls(stub func(context.Context, string, container.StartOptions) error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = stub
}

func (fake *FakeDockerAPI) ContainerStartArgsForCall(i int) (context.Context, string, container.StartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	argsForCall := fake.containerStartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ContainerStartReturns(result1 error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) ContainerStop(arg1 context.Context, arg2 string, arg3 container.StopOptions) error {
	fake.containerStopMutex.Lock()
	ret, specificReturn := fake.containerStopReturnsOnCall[len(fake.containerStopArgsForCall)]
	fake.containerStopArgsForCall = append(fake.containerStopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.StopOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerStopStub
	fakeReturns := fake.containerStopReturns
	fake.recordInvocation("ContainerStop", []interface{}{arg1, arg2, arg3})
	fake.containerStopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) ContainerStopCallCount() int {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return len(fake.containerStopArgsForCall)
}

func (fake *FakeDockerAPI) ContainerStopCalls(stub func(context.Context, string, container.StopOptions) error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = stub
}

func (fake *FakeDockerAPI) ContainerStopArgsForCall(i int) (context.Context, string, container.StopOptions) {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	argsForCall := fake.containerStopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ContainerStopReturns(result1 error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = nil
	fake.containerStopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) ContainerStopReturnsOnCall(i int, result1 error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = nil
	if fake.containerStopReturnsOnCall == nil {
		fake.containerStopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) DaemonHost() string {
	fake.daemonHostMutex.Lock()
	ret, specificReturn := fake.daemonHostReturnsOnCall[len(fake.daemonHostArgsForCall)]
	fake.daemonHostArgsForCall = append(fake.daemonHostArgsForCall, struct {
	}{})
	stub := fake.DaemonHostStub
	fakeReturns := fake.daemonHostReturns
	fake.recordInvocation("DaemonHost", []interface{}{})
	fake.daemonHostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) DaemonHostCallCount() int {
	fake.daemonHostMutex.RLock()
	defer fake.daemonHostMutex.RUnlock()
	return len(fake.daemonHostArgsForCall)
}

func (fake *FakeDockerAPI) DaemonHostCalls(stub func() string) {
	fake.daemonHostMutex.Lock()
	defer fake.daemonHostMutex.Unlock()
	fake.DaemonHostStub = stub
}

func (fake *FakeDockerAPI) DaemonHostReturns(result1 string) {
	fake.daemonHostMutex.Lock()
	defer fake.daemonHostMutex.Unlock()
	fake.DaemonHostStub = nil
	fake.daemonHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDockerAPI) DaemonHostReturnsOnCall(i int, result1 string) {
	fake.daemonHostMutex.Lock()
	defer fake.daemonHostMutex.Unlock()
	fake.DaemonHostStub = nil
	if fake.daemonHostReturnsOnCall == nil {
		fake.daemonHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.daemonHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeDockerAPI) DistributionInspect(arg1 context.Context, arg2 string, arg3 string) (registry.DistributionInspect, error) {
	fake.distributionInspectMutex.Lock()
	ret, specificReturn := fake.distributionInspectReturnsOnCall[len(fake.distributionInspectArgsForCall)]
	fake.distributionInspectArgsForCall = append(fake.distributionInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DistributionInspectStub
	fakeReturns := fake.distributionInspectReturns
	fake.recordInvocation("DistributionInspect", []interface{}{arg1, arg2, arg3})
	fake.distributionInspectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) DistributionInspectCallCount() int {
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	return len(fake.distributionInspectArgsForCall)
}

func (fake *FakeDockerAPI) DistributionInspectCalls(stub func(context.Context, string, string) (registry.DistributionInspect, error)) {
	fake.distributionInspectMutex.Lock()
	defer fake.distributionInspectMutex.Unlock()
	fake.DistributionInspectStub = stub
}

func (fake *FakeDockerAPI) DistributionInspectArgsForCall(i int) (context.Context, string, string) {
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	argsForCall := fake.distributionInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) DistributionInspectReturns(result1 registry.DistributionInspect, result2 error) {
	fake.distributionInspectMutex.Lock()
	defer fake.distributionInspectMutex.Unlock()
	fake.DistributionInspectStub = nil
	fake.distributionInspectReturns = struct {
		result1 registry.DistributionInspect
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) DistributionInspectReturnsOnCall(i int, result1 registry.DistributionInspect, result2 error) {
	fake.distributionInspectMutex.Lock()
	defer fake.distributionInspectMutex.Unlock()
	fake.DistributionInspectStub = nil
	if fake.distributionInspectReturnsOnCall == nil {
		fake.distributionInspectReturnsOnCall = make(map[int]struct {
			result1 registry.DistributionInspect
			result2 error
		})
	}
	fake.distributionInspectReturnsOnCall[i] = struct {
		result1 registry.DistributionInspect
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ImageInspectWithRaw(arg1 context.Context, arg2 string) (types.ImageInspect, []byte, error) {
	fake.imageInspectWithRawMutex.Lock()
	ret, specificReturn := fake.imageInspectWithRawReturnsOnCall[len(fake.imageInspectWithRawArgsForCall)]
	fake.imageInspectWithRawArgsForCall = append(fake.imageInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ImageInspectWithRawStub
	fakeReturns := fake.imageInspectWithRawReturns
	fake.recordInvocation("ImageInspectWithRaw", []interface{}{arg1, arg2})
	fake.imageInspectWithRawMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDockerAPI) ImageInspectWithRawCallCount() int {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	return len(fake.imageInspectWithRawArgsForCall)
}

func (fake *FakeDockerAPI) ImageInspectWithRawCalls(stub func(context.Context, string) (types.ImageInspect, []byte, error)) {
	fake.imageInspectWithRawMutex.Lock()
	defer fake.imageInspectWithRawMutex.Unlock()
	fake.ImageInspectWithRawStub = stub
}

func (fake *FakeDockerAPI) ImageInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	argsForCall := fake.imageInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) ImageInspectWithRawReturns(result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.imageInspectWithRawMutex.Lock()
	defer fake.imageInspectWithRawMutex.Unlock()
	fake.ImageInspectWithRawStub = nil
	fake.imageInspectWithRawReturns = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerAPI) ImageInspectWithRawReturnsOnCall(i int, result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.imageInspectWithRawMutex.Lock()
	defer fake.imageInspectWithRawMutex.Unlock()
	fake.ImageInspectWithRawStub = nil
	if fake.imageInspectWithRawReturnsOnCall == nil {
		fake.imageInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ImageInspect
			result2 []byte
			result3 error
		})
	}
	fake.imageInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerAPI) ImagePull(arg1 context.Context, arg2 string, arg3 image.PullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	ret, specificReturn := fake.imagePullReturnsOnCall[len(fake.imagePullArgsForCall)]
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 image.PullOptions
	}{arg1, arg2, arg3})
	stub := fake.ImagePullStub
	fakeReturns := fake.imagePullReturns
	fake.recordInvocation("ImagePull", []interface{}{arg1, arg2, arg3})
	fake.imagePullMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *FakeDockerAPI) ImagePullCalls(stub func(context.Context, string, image.PullOptions) (io.ReadCloser, error)) {
	fake.imagePullMutex.Lock()
	defer fake.imagePullMutex.Unlock()
	fake.ImagePullStub = stub
}

func (fake *FakeDockerAPI) ImagePullArgsForCall(i int) (context.Context, string, image.PullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	argsForCall := fake.imagePullArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.imagePullMutex.Lock()
	defer fake.imagePullMutex.Unlock()
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) ImagePullReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imagePullMutex.Lock()
	defer fake.imagePullMutex.Unlock()
	fake.ImagePullStub = nil
	if fake.imagePullReturnsOnCall == nil {
		fake.imagePullReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePullReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) NetworkCreate(arg1 context.Context, arg2 string, arg3 network.CreateOptions) (network.CreateResponse, error) {
	fake.networkCreateMutex.Lock()
	ret, specificReturn := fake.networkCreateReturnsOnCall[len(fake.networkCreateArgsForCall)]
	fake.networkCreateArgsForCall = append(fake.networkCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 network.CreateOptions
	}{arg1, arg2, arg3})
	stub := fake.NetworkCreateStub
	fakeReturns := fake.networkCreateReturns
	fake.recordInvocation("NetworkCreate", []interface{}{arg1, arg2, arg3})
	fake.networkCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) NetworkCreateCallCount() int {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return len(fake.networkCreateArgsForCall)
}

func (fake *FakeDockerAPI) NetworkCreateCalls(stub func(context.Context, string, network.CreateOptions) (network.CreateResponse, error)) {
	fake.networkCreateMutex.Lock()
	defer fake.networkCreateMutex.Unlock()
	fake.NetworkCreateStub = stub
}

func (fake *FakeDockerAPI) NetworkCreateArgsForCall(i int) (context.Context, string, network.CreateOptions) {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	argsForCall := fake.networkCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) NetworkCreateReturns(result1 network.CreateResponse, result2 error) {
	fake.networkCreateMutex.Lock()
	defer fake.networkCreateMutex.Unlock()
	fake.NetworkCreateStub = nil
	fake.networkCreateReturns = struct {
		result1 network.CreateResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) NetworkCreateReturnsOnCall(i int, result1 network.CreateResponse, result2 error) {
	fake.networkCreateMutex.Lock()
	defer fake.networkCreateMutex.Unlock()
	fake.NetworkCreateStub = nil
	if fake.networkCreateReturnsOnCall == nil {
		fake.networkCreateReturnsOnCall = make(map[int]struct {
			result1 network.CreateResponse
			result2 error
		})
	}
	fake.networkCreateReturnsOnCall[i] = struct {
		result1 network.CreateResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) NetworkInspect(arg1 context.Context, arg2 string, arg3 network.InspectOptions) (network.Inspect, error) {
	fake.networkInspectMutex.Lock()
	ret, specificReturn := fake.networkInspectReturnsOnCall[len(fake.networkInspectArgsForCall)]
	fake.networkInspectArgsForCall = append(fake.networkInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 network.InspectOptions
	}{arg1, arg2, arg3})
	stub := fake.NetworkInspectStub
	fakeReturns := fake.networkInspectReturns
	fake.recordInvocation("NetworkInspect", []interface{}{arg1, arg2, arg3})
	fake.networkInspectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) NetworkInspectCallCount() int {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	return len(fake.networkInspectArgsForCall)
}

func (fake *FakeDockerAPI) NetworkInspectCalls(stub func(context.Context, string, network.InspectOptions) (network.Inspect, error)) {
	fake.networkInspectMutex.Lock()
	defer fake.networkInspectMutex.Unlock()
	fake.NetworkInspectStub = stub
}

func (fake *FakeDockerAPI) NetworkInspectArgsForCall(i int) (context.Context, string, network.InspectOptions) {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	argsForCall := fake.networkInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) NetworkInspectReturns(result1 network.Inspect, result2 error) {
	fake.networkInspectMutex.Lock()
	defer fake.networkInspectMutex.Unlock()
	fake.NetworkInspectStub = nil
	fake.networkInspectReturns = struct {
		result1 network.Inspect
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) NetworkInspectReturnsOnCall(i int, result1 network.Inspect, result2 error) {
	fake.networkInspectMutex.Lock()
	defer fake.networkInspectMutex.Unlock()
	fake.NetworkInspectStub = nil
	if fake.networkInspectReturnsOnCall == nil {
		fake.networkInspectReturnsOnCall = make(map[int]struct {
			result1 network.Inspect
			result2 error
		})
	}
	fake.networkInspectReturnsOnCall[i] = struct {
		result1 network.Inspect
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) NetworkRemove(arg1 context.Context, arg2 string) error {
	fake.networkRemoveMutex.Lock()
	ret, specificReturn := fake.networkRemoveReturnsOnCall[len(fake.networkRemoveArgsForCall)]
	fake.networkRemoveArgsForCall = append(fake.networkRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.NetworkRemoveStub
	fakeReturns := fake.networkRemoveReturns
	fake.recordInvocation("NetworkRemove", []interface{}{arg1, arg2})
	fake.networkRemoveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) NetworkRemoveCallCount() int {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	return len(fake.networkRemoveArgsForCall)
}

func (fake *FakeDockerAPI) NetworkRemoveCalls(stub func(context.Context, string) error) {
	fake.networkRemoveMutex.Lock()
	defer fake.networkRemoveMutex.Unlock()
	fake.NetworkRemoveStub = stub
}

func (fake *FakeDockerAPI) NetworkRemoveArgsForCall(i int) (context.Context, string) {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	argsForCall := fake.networkRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) NetworkRemoveReturns(result1 error) {
	fake.networkRemoveMutex.Lock()
	defer fake.networkRemoveMutex.Unlock()
	fake.NetworkRemoveStub = nil
	fake.networkRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) NetworkRemoveReturnsOnCall(i int, result1 error) {
	fake.networkRemoveMutex.Lock()
	defer fake.networkRemoveMutex.Unlock()
	fake.NetworkRemoveStub = nil
	if fake.networkRemoveReturnsOnCall == nil {
		fake.networkRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) VolumeCreate(arg1 context.Context, arg2 volume.CreateOptions) (volume.Volume, error) {
	fake.volumeCreateMutex.Lock()
	ret, specificReturn := fake.volumeCreateReturnsOnCall[len(fake.volumeCreateArgsForCall)]
	fake.volumeCreateArgsForCall = append(fake.volumeCreateArgsForCall, struct {
		arg1 context.Context
		arg2 volume.CreateOptions
	}{arg1, arg2})
	stub := fake.VolumeCreateStub
	fakeReturns := fake.volumeCreateReturns
	fake.recordInvocation("VolumeCreate", []interface{}{arg1, arg2})
	fake.volumeCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) VolumeCreateCallCount() int {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	return len(fake.volumeCreateArgsForCall)
}

func (fake *FakeDockerAPI) VolumeCreateCalls(stub func(context.Context, volume.CreateOptions) (volume.Volume, error)) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = stub
}

func (fake *FakeDockerAPI) VolumeCreateArgsForCall(i int) (context.Context, volume.CreateOptions) {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	argsForCall := fake.volumeCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) VolumeCreateReturns(result1 volume.Volume, result2 error) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = nil
	fake.volumeCreateReturns = struct {
		result1 volume.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) VolumeCreateReturnsOnCall(i int, result1 volume.Volume, result2 error) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = nil
	if fake.volumeCreateReturnsOnCall == nil {
		fake.volumeCreateReturnsOnCall = make(map[int]struct {
			result1 volume.Volume
			result2 error
		})
	}
	fake.volumeCreateReturnsOnCall[i] = struct {
		result1 volume.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) VolumeInspect(arg1 context.Context, arg2 string) (volume.Volume, error) {
	fake.volumeInspectMutex.Lock()
	ret, specificReturn := fake.volumeInspectReturnsOnCall[len(fake.volumeInspectArgsForCall)]
	fake.volumeInspectArgsForCall = append(fake.volumeInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.VolumeInspectStub
	fakeReturns := fake.volumeInspectReturns
	fake.recordInvocation("VolumeInspect", []interface{}{arg1, arg2})
	fake.volumeInspectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDockerAPI) VolumeInspectCallCount() int {
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	return len(fake.volumeInspectArgsForCall)
}

func (fake *FakeDockerAPI) VolumeInspectCalls(stub func(context.Context, string) (volume.Volume, error)) {
	fake.volumeInspectMutex.Lock()
	defer fake.volumeInspectMutex.Unlock()
	fake.VolumeInspectStub = stub
}

func (fake *FakeDockerAPI) VolumeInspectArgsForCall(i int) (context.Context, string) {
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	argsForCall := fake.volumeInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDockerAPI) VolumeInspectReturns(result1 volume.Volume, result2 error) {
	fake.volumeInspectMutex.Lock()
	defer fake.volumeInspectMutex.Unlock()
	fake.VolumeInspectStub = nil
	fake.volumeInspectReturns = struct {
		result1 volume.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) VolumeInspectReturnsOnCall(i int, result1 volume.Volume, result2 error) {
	fake.volumeInspectMutex.Lock()
	defer fake.volumeInspectMutex.Unlock()
	fake.VolumeInspectStub = nil
	if fake.volumeInspectReturnsOnCall == nil {
		fake.volumeInspectReturnsOnCall = make(map[int]struct {
			result1 volume.Volume
			result2 error
		})
	}
	fake.volumeInspectReturnsOnCall[i] = struct {
		result1 volume.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerAPI) VolumeRemove(arg1 context.Context, arg2 string, arg3 bool) error {
	fake.volumeRemoveMutex.Lock()
	ret, specificReturn := fake.volumeRemoveReturnsOnCall[len(fake.volumeRemoveArgsForCall)]
	fake.volumeRemoveArgsForCall = append(fake.volumeRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.VolumeRemoveStub
	fakeReturns := fake.volumeRemoveReturns
	fake.recordInvocation("VolumeRemove", []interface{}{arg1, arg2, arg3})
	fake.volumeRemoveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDockerAPI) VolumeRemoveCallCount() int {
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	return len(fake.volumeRemoveArgsForCall)
}

func (fake *FakeDockerAPI) VolumeRemoveCalls(stub func(context.Context, string, bool) error) {
	fake.volumeRemoveMutex.Lock()
	defer fake.volumeRemoveMutex.Unlock()
	fake.VolumeRemoveStub = stub
}

func (fake *FakeDockerAPI) VolumeRemoveArgsForCall(i int) (context.Context, string, bool) {
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	argsForCall := fake.volumeRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDockerAPI) VolumeRemoveReturns(result1 error) {
	fake.volumeRemoveMutex.Lock()
	defer fake.volumeRemoveMutex.Unlock()
	fake.VolumeRemoveStub = nil
	fake.volumeRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) VolumeRemoveReturnsOnCall(i int, result1 error) {
	fake.volumeRemoveMutex.Lock()
	defer fake.volumeRemoveMutex.Unlock()
	fake.VolumeRemoveStub = nil
	if fake.volumeRemoveReturnsOnCall == nil {
		fake.volumeRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDockerAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ docker.DockerAPI = new(FakeDockerAPI)
