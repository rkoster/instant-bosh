// Code generated by counterfeiter. DO NOT EDIT.
package cpifakes

import (
	"context"
	"io"
	"sync"
	"time"

	"github.com/rkoster/instant-bosh/internal/cpi"
)

type FakeCPI struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func(context.Context) error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
		arg1 context.Context
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	EnsurePrerequisitesStub        func(context.Context) error
	ensurePrerequisitesMutex       sync.RWMutex
	ensurePrerequisitesArgsForCall []struct {
		arg1 context.Context
	}
	ensurePrerequisitesReturns struct {
		result1 error
	}
	ensurePrerequisitesReturnsOnCall map[int]struct {
		result1 error
	}
	ExecCommandStub        func(context.Context, string, []string) (string, error)
	execCommandMutex       sync.RWMutex
	execCommandArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	execCommandReturns struct {
		result1 string
		result2 error
	}
	execCommandReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExistsStub        func(context.Context) (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 context.Context
	}
	existsReturns struct {
		result1 bool
		result2 error
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FollowLogsStub        func(context.Context, io.Writer, io.Writer) error
	followLogsMutex       sync.RWMutex
	followLogsArgsForCall []struct {
		arg1 context.Context
		arg2 io.Writer
		arg3 io.Writer
	}
	followLogsReturns struct {
		result1 error
	}
	followLogsReturnsOnCall map[int]struct {
		result1 error
	}
	FollowLogsWithOptionsStub        func(context.Context, bool, string, io.Writer, io.Writer) error
	followLogsWithOptionsMutex       sync.RWMutex
	followLogsWithOptionsArgsForCall []struct {
		arg1 context.Context
		arg2 bool
		arg3 string
		arg4 io.Writer
		arg5 io.Writer
	}
	followLogsWithOptionsReturns struct {
		result1 error
	}
	followLogsWithOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	GetCloudConfigBytesStub        func() []byte
	getCloudConfigBytesMutex       sync.RWMutex
	getCloudConfigBytesArgsForCall []struct {
	}
	getCloudConfigBytesReturns struct {
		result1 []byte
	}
	getCloudConfigBytesReturnsOnCall map[int]struct {
		result1 []byte
	}
	GetContainerNameStub        func() string
	getContainerNameMutex       sync.RWMutex
	getContainerNameArgsForCall []struct {
	}
	getContainerNameReturns struct {
		result1 string
	}
	getContainerNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetContainersOnNetworkStub        func(context.Context) ([]cpi.ContainerInfo, error)
	getContainersOnNetworkMutex       sync.RWMutex
	getContainersOnNetworkArgsForCall []struct {
		arg1 context.Context
	}
	getContainersOnNetworkReturns struct {
		result1 []cpi.ContainerInfo
		result2 error
	}
	getContainersOnNetworkReturnsOnCall map[int]struct {
		result1 []cpi.ContainerInfo
		result2 error
	}
	GetHostAddressStub        func() string
	getHostAddressMutex       sync.RWMutex
	getHostAddressArgsForCall []struct {
	}
	getHostAddressReturns struct {
		result1 string
	}
	getHostAddressReturnsOnCall map[int]struct {
		result1 string
	}
	GetLogsStub        func(context.Context, string) (string, error)
	getLogsMutex       sync.RWMutex
	getLogsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getLogsReturns struct {
		result1 string
		result2 error
	}
	getLogsReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IsRunningStub        func(context.Context) (bool, error)
	isRunningMutex       sync.RWMutex
	isRunningArgsForCall []struct {
		arg1 context.Context
	}
	isRunningReturns struct {
		result1 bool
		result2 error
	}
	isRunningReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	StartStub        func(context.Context) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 context.Context
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func(context.Context) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		arg1 context.Context
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForReadyStub        func(context.Context, time.Duration) error
	waitForReadyMutex       sync.RWMutex
	waitForReadyArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
	}
	waitForReadyReturns struct {
		result1 error
	}
	waitForReadyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCPI) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeCPI) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeCPI) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) Destroy(arg1 context.Context) error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DestroyStub
	fakeReturns := fake.destroyReturns
	fake.recordInvocation("Destroy", []interface{}{arg1})
	fake.destroyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeCPI) DestroyCalls(stub func(context.Context) error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeCPI) DestroyArgsForCall(i int) context.Context {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	argsForCall := fake.destroyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) EnsurePrerequisites(arg1 context.Context) error {
	fake.ensurePrerequisitesMutex.Lock()
	ret, specificReturn := fake.ensurePrerequisitesReturnsOnCall[len(fake.ensurePrerequisitesArgsForCall)]
	fake.ensurePrerequisitesArgsForCall = append(fake.ensurePrerequisitesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.EnsurePrerequisitesStub
	fakeReturns := fake.ensurePrerequisitesReturns
	fake.recordInvocation("EnsurePrerequisites", []interface{}{arg1})
	fake.ensurePrerequisitesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) EnsurePrerequisitesCallCount() int {
	fake.ensurePrerequisitesMutex.RLock()
	defer fake.ensurePrerequisitesMutex.RUnlock()
	return len(fake.ensurePrerequisitesArgsForCall)
}

func (fake *FakeCPI) EnsurePrerequisitesCalls(stub func(context.Context) error) {
	fake.ensurePrerequisitesMutex.Lock()
	defer fake.ensurePrerequisitesMutex.Unlock()
	fake.EnsurePrerequisitesStub = stub
}

func (fake *FakeCPI) EnsurePrerequisitesArgsForCall(i int) context.Context {
	fake.ensurePrerequisitesMutex.RLock()
	defer fake.ensurePrerequisitesMutex.RUnlock()
	argsForCall := fake.ensurePrerequisitesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) EnsurePrerequisitesReturns(result1 error) {
	fake.ensurePrerequisitesMutex.Lock()
	defer fake.ensurePrerequisitesMutex.Unlock()
	fake.EnsurePrerequisitesStub = nil
	fake.ensurePrerequisitesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) EnsurePrerequisitesReturnsOnCall(i int, result1 error) {
	fake.ensurePrerequisitesMutex.Lock()
	defer fake.ensurePrerequisitesMutex.Unlock()
	fake.EnsurePrerequisitesStub = nil
	if fake.ensurePrerequisitesReturnsOnCall == nil {
		fake.ensurePrerequisitesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensurePrerequisitesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) ExecCommand(arg1 context.Context, arg2 string, arg3 []string) (string, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.execCommandMutex.Lock()
	ret, specificReturn := fake.execCommandReturnsOnCall[len(fake.execCommandArgsForCall)]
	fake.execCommandArgsForCall = append(fake.execCommandArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.ExecCommandStub
	fakeReturns := fake.execCommandReturns
	fake.recordInvocation("ExecCommand", []interface{}{arg1, arg2, arg3Copy})
	fake.execCommandMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCPI) ExecCommandCallCount() int {
	fake.execCommandMutex.RLock()
	defer fake.execCommandMutex.RUnlock()
	return len(fake.execCommandArgsForCall)
}

func (fake *FakeCPI) ExecCommandCalls(stub func(context.Context, string, []string) (string, error)) {
	fake.execCommandMutex.Lock()
	defer fake.execCommandMutex.Unlock()
	fake.ExecCommandStub = stub
}

func (fake *FakeCPI) ExecCommandArgsForCall(i int) (context.Context, string, []string) {
	fake.execCommandMutex.RLock()
	defer fake.execCommandMutex.RUnlock()
	argsForCall := fake.execCommandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCPI) ExecCommandReturns(result1 string, result2 error) {
	fake.execCommandMutex.Lock()
	defer fake.execCommandMutex.Unlock()
	fake.ExecCommandStub = nil
	fake.execCommandReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) ExecCommandReturnsOnCall(i int, result1 string, result2 error) {
	fake.execCommandMutex.Lock()
	defer fake.execCommandMutex.Unlock()
	fake.ExecCommandStub = nil
	if fake.execCommandReturnsOnCall == nil {
		fake.execCommandReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.execCommandReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) Exists(arg1 context.Context) (bool, error) {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ExistsStub
	fakeReturns := fake.existsReturns
	fake.recordInvocation("Exists", []interface{}{arg1})
	fake.existsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCPI) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeCPI) ExistsCalls(stub func(context.Context) (bool, error)) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *FakeCPI) ExistsArgsForCall(i int) context.Context {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) ExistsReturns(result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) ExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) FollowLogs(arg1 context.Context, arg2 io.Writer, arg3 io.Writer) error {
	fake.followLogsMutex.Lock()
	ret, specificReturn := fake.followLogsReturnsOnCall[len(fake.followLogsArgsForCall)]
	fake.followLogsArgsForCall = append(fake.followLogsArgsForCall, struct {
		arg1 context.Context
		arg2 io.Writer
		arg3 io.Writer
	}{arg1, arg2, arg3})
	stub := fake.FollowLogsStub
	fakeReturns := fake.followLogsReturns
	fake.recordInvocation("FollowLogs", []interface{}{arg1, arg2, arg3})
	fake.followLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) FollowLogsCallCount() int {
	fake.followLogsMutex.RLock()
	defer fake.followLogsMutex.RUnlock()
	return len(fake.followLogsArgsForCall)
}

func (fake *FakeCPI) FollowLogsCalls(stub func(context.Context, io.Writer, io.Writer) error) {
	fake.followLogsMutex.Lock()
	defer fake.followLogsMutex.Unlock()
	fake.FollowLogsStub = stub
}

func (fake *FakeCPI) FollowLogsArgsForCall(i int) (context.Context, io.Writer, io.Writer) {
	fake.followLogsMutex.RLock()
	defer fake.followLogsMutex.RUnlock()
	argsForCall := fake.followLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCPI) FollowLogsReturns(result1 error) {
	fake.followLogsMutex.Lock()
	defer fake.followLogsMutex.Unlock()
	fake.FollowLogsStub = nil
	fake.followLogsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) FollowLogsReturnsOnCall(i int, result1 error) {
	fake.followLogsMutex.Lock()
	defer fake.followLogsMutex.Unlock()
	fake.FollowLogsStub = nil
	if fake.followLogsReturnsOnCall == nil {
		fake.followLogsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.followLogsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) FollowLogsWithOptions(arg1 context.Context, arg2 bool, arg3 string, arg4 io.Writer, arg5 io.Writer) error {
	fake.followLogsWithOptionsMutex.Lock()
	ret, specificReturn := fake.followLogsWithOptionsReturnsOnCall[len(fake.followLogsWithOptionsArgsForCall)]
	fake.followLogsWithOptionsArgsForCall = append(fake.followLogsWithOptionsArgsForCall, struct {
		arg1 context.Context
		arg2 bool
		arg3 string
		arg4 io.Writer
		arg5 io.Writer
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.FollowLogsWithOptionsStub
	fakeReturns := fake.followLogsWithOptionsReturns
	fake.recordInvocation("FollowLogsWithOptions", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.followLogsWithOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) FollowLogsWithOptionsCallCount() int {
	fake.followLogsWithOptionsMutex.RLock()
	defer fake.followLogsWithOptionsMutex.RUnlock()
	return len(fake.followLogsWithOptionsArgsForCall)
}

func (fake *FakeCPI) FollowLogsWithOptionsCalls(stub func(context.Context, bool, string, io.Writer, io.Writer) error) {
	fake.followLogsWithOptionsMutex.Lock()
	defer fake.followLogsWithOptionsMutex.Unlock()
	fake.FollowLogsWithOptionsStub = stub
}

func (fake *FakeCPI) FollowLogsWithOptionsArgsForCall(i int) (context.Context, bool, string, io.Writer, io.Writer) {
	fake.followLogsWithOptionsMutex.RLock()
	defer fake.followLogsWithOptionsMutex.RUnlock()
	argsForCall := fake.followLogsWithOptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeCPI) FollowLogsWithOptionsReturns(result1 error) {
	fake.followLogsWithOptionsMutex.Lock()
	defer fake.followLogsWithOptionsMutex.Unlock()
	fake.FollowLogsWithOptionsStub = nil
	fake.followLogsWithOptionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) FollowLogsWithOptionsReturnsOnCall(i int, result1 error) {
	fake.followLogsWithOptionsMutex.Lock()
	defer fake.followLogsWithOptionsMutex.Unlock()
	fake.FollowLogsWithOptionsStub = nil
	if fake.followLogsWithOptionsReturnsOnCall == nil {
		fake.followLogsWithOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.followLogsWithOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) GetCloudConfigBytes() []byte {
	fake.getCloudConfigBytesMutex.Lock()
	ret, specificReturn := fake.getCloudConfigBytesReturnsOnCall[len(fake.getCloudConfigBytesArgsForCall)]
	fake.getCloudConfigBytesArgsForCall = append(fake.getCloudConfigBytesArgsForCall, struct {
	}{})
	stub := fake.GetCloudConfigBytesStub
	fakeReturns := fake.getCloudConfigBytesReturns
	fake.recordInvocation("GetCloudConfigBytes", []interface{}{})
	fake.getCloudConfigBytesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) GetCloudConfigBytesCallCount() int {
	fake.getCloudConfigBytesMutex.RLock()
	defer fake.getCloudConfigBytesMutex.RUnlock()
	return len(fake.getCloudConfigBytesArgsForCall)
}

func (fake *FakeCPI) GetCloudConfigBytesCalls(stub func() []byte) {
	fake.getCloudConfigBytesMutex.Lock()
	defer fake.getCloudConfigBytesMutex.Unlock()
	fake.GetCloudConfigBytesStub = stub
}

func (fake *FakeCPI) GetCloudConfigBytesReturns(result1 []byte) {
	fake.getCloudConfigBytesMutex.Lock()
	defer fake.getCloudConfigBytesMutex.Unlock()
	fake.GetCloudConfigBytesStub = nil
	fake.getCloudConfigBytesReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeCPI) GetCloudConfigBytesReturnsOnCall(i int, result1 []byte) {
	fake.getCloudConfigBytesMutex.Lock()
	defer fake.getCloudConfigBytesMutex.Unlock()
	fake.GetCloudConfigBytesStub = nil
	if fake.getCloudConfigBytesReturnsOnCall == nil {
		fake.getCloudConfigBytesReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.getCloudConfigBytesReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeCPI) GetContainerName() string {
	fake.getContainerNameMutex.Lock()
	ret, specificReturn := fake.getContainerNameReturnsOnCall[len(fake.getContainerNameArgsForCall)]
	fake.getContainerNameArgsForCall = append(fake.getContainerNameArgsForCall, struct {
	}{})
	stub := fake.GetContainerNameStub
	fakeReturns := fake.getContainerNameReturns
	fake.recordInvocation("GetContainerName", []interface{}{})
	fake.getContainerNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) GetContainerNameCallCount() int {
	fake.getContainerNameMutex.RLock()
	defer fake.getContainerNameMutex.RUnlock()
	return len(fake.getContainerNameArgsForCall)
}

func (fake *FakeCPI) GetContainerNameCalls(stub func() string) {
	fake.getContainerNameMutex.Lock()
	defer fake.getContainerNameMutex.Unlock()
	fake.GetContainerNameStub = stub
}

func (fake *FakeCPI) GetContainerNameReturns(result1 string) {
	fake.getContainerNameMutex.Lock()
	defer fake.getContainerNameMutex.Unlock()
	fake.GetContainerNameStub = nil
	fake.getContainerNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCPI) GetContainerNameReturnsOnCall(i int, result1 string) {
	fake.getContainerNameMutex.Lock()
	defer fake.getContainerNameMutex.Unlock()
	fake.GetContainerNameStub = nil
	if fake.getContainerNameReturnsOnCall == nil {
		fake.getContainerNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getContainerNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCPI) GetContainersOnNetwork(arg1 context.Context) ([]cpi.ContainerInfo, error) {
	fake.getContainersOnNetworkMutex.Lock()
	ret, specificReturn := fake.getContainersOnNetworkReturnsOnCall[len(fake.getContainersOnNetworkArgsForCall)]
	fake.getContainersOnNetworkArgsForCall = append(fake.getContainersOnNetworkArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetContainersOnNetworkStub
	fakeReturns := fake.getContainersOnNetworkReturns
	fake.recordInvocation("GetContainersOnNetwork", []interface{}{arg1})
	fake.getContainersOnNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCPI) GetContainersOnNetworkCallCount() int {
	fake.getContainersOnNetworkMutex.RLock()
	defer fake.getContainersOnNetworkMutex.RUnlock()
	return len(fake.getContainersOnNetworkArgsForCall)
}

func (fake *FakeCPI) GetContainersOnNetworkCalls(stub func(context.Context) ([]cpi.ContainerInfo, error)) {
	fake.getContainersOnNetworkMutex.Lock()
	defer fake.getContainersOnNetworkMutex.Unlock()
	fake.GetContainersOnNetworkStub = stub
}

func (fake *FakeCPI) GetContainersOnNetworkArgsForCall(i int) context.Context {
	fake.getContainersOnNetworkMutex.RLock()
	defer fake.getContainersOnNetworkMutex.RUnlock()
	argsForCall := fake.getContainersOnNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) GetContainersOnNetworkReturns(result1 []cpi.ContainerInfo, result2 error) {
	fake.getContainersOnNetworkMutex.Lock()
	defer fake.getContainersOnNetworkMutex.Unlock()
	fake.GetContainersOnNetworkStub = nil
	fake.getContainersOnNetworkReturns = struct {
		result1 []cpi.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) GetContainersOnNetworkReturnsOnCall(i int, result1 []cpi.ContainerInfo, result2 error) {
	fake.getContainersOnNetworkMutex.Lock()
	defer fake.getContainersOnNetworkMutex.Unlock()
	fake.GetContainersOnNetworkStub = nil
	if fake.getContainersOnNetworkReturnsOnCall == nil {
		fake.getContainersOnNetworkReturnsOnCall = make(map[int]struct {
			result1 []cpi.ContainerInfo
			result2 error
		})
	}
	fake.getContainersOnNetworkReturnsOnCall[i] = struct {
		result1 []cpi.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) GetHostAddress() string {
	fake.getHostAddressMutex.Lock()
	ret, specificReturn := fake.getHostAddressReturnsOnCall[len(fake.getHostAddressArgsForCall)]
	fake.getHostAddressArgsForCall = append(fake.getHostAddressArgsForCall, struct {
	}{})
	stub := fake.GetHostAddressStub
	fakeReturns := fake.getHostAddressReturns
	fake.recordInvocation("GetHostAddress", []interface{}{})
	fake.getHostAddressMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) GetHostAddressCallCount() int {
	fake.getHostAddressMutex.RLock()
	defer fake.getHostAddressMutex.RUnlock()
	return len(fake.getHostAddressArgsForCall)
}

func (fake *FakeCPI) GetHostAddressCalls(stub func() string) {
	fake.getHostAddressMutex.Lock()
	defer fake.getHostAddressMutex.Unlock()
	fake.GetHostAddressStub = stub
}

func (fake *FakeCPI) GetHostAddressReturns(result1 string) {
	fake.getHostAddressMutex.Lock()
	defer fake.getHostAddressMutex.Unlock()
	fake.GetHostAddressStub = nil
	fake.getHostAddressReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCPI) GetHostAddressReturnsOnCall(i int, result1 string) {
	fake.getHostAddressMutex.Lock()
	defer fake.getHostAddressMutex.Unlock()
	fake.GetHostAddressStub = nil
	if fake.getHostAddressReturnsOnCall == nil {
		fake.getHostAddressReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getHostAddressReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCPI) GetLogs(arg1 context.Context, arg2 string) (string, error) {
	fake.getLogsMutex.Lock()
	ret, specificReturn := fake.getLogsReturnsOnCall[len(fake.getLogsArgsForCall)]
	fake.getLogsArgsForCall = append(fake.getLogsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetLogsStub
	fakeReturns := fake.getLogsReturns
	fake.recordInvocation("GetLogs", []interface{}{arg1, arg2})
	fake.getLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCPI) GetLogsCallCount() int {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	return len(fake.getLogsArgsForCall)
}

func (fake *FakeCPI) GetLogsCalls(stub func(context.Context, string) (string, error)) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = stub
}

func (fake *FakeCPI) GetLogsArgsForCall(i int) (context.Context, string) {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	argsForCall := fake.getLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCPI) GetLogsReturns(result1 string, result2 error) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	fake.getLogsReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) GetLogsReturnsOnCall(i int, result1 string, result2 error) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	if fake.getLogsReturnsOnCall == nil {
		fake.getLogsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getLogsReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) IsRunning(arg1 context.Context) (bool, error) {
	fake.isRunningMutex.Lock()
	ret, specificReturn := fake.isRunningReturnsOnCall[len(fake.isRunningArgsForCall)]
	fake.isRunningArgsForCall = append(fake.isRunningArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.IsRunningStub
	fakeReturns := fake.isRunningReturns
	fake.recordInvocation("IsRunning", []interface{}{arg1})
	fake.isRunningMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCPI) IsRunningCallCount() int {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	return len(fake.isRunningArgsForCall)
}

func (fake *FakeCPI) IsRunningCalls(stub func(context.Context) (bool, error)) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = stub
}

func (fake *FakeCPI) IsRunningArgsForCall(i int) context.Context {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	argsForCall := fake.isRunningArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) IsRunningReturns(result1 bool, result2 error) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	fake.isRunningReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) IsRunningReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	if fake.isRunningReturnsOnCall == nil {
		fake.isRunningReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isRunningReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCPI) Start(arg1 context.Context) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartStub
	fakeReturns := fake.startReturns
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeCPI) StartCalls(stub func(context.Context) error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeCPI) StartArgsForCall(i int) context.Context {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	argsForCall := fake.startArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) Stop(arg1 context.Context) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StopStub
	fakeReturns := fake.stopReturns
	fake.recordInvocation("Stop", []interface{}{arg1})
	fake.stopMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeCPI) StopCalls(stub func(context.Context) error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeCPI) StopArgsForCall(i int) context.Context {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	argsForCall := fake.stopArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCPI) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) WaitForReady(arg1 context.Context, arg2 time.Duration) error {
	fake.waitForReadyMutex.Lock()
	ret, specificReturn := fake.waitForReadyReturnsOnCall[len(fake.waitForReadyArgsForCall)]
	fake.waitForReadyArgsForCall = append(fake.waitForReadyArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.WaitForReadyStub
	fakeReturns := fake.waitForReadyReturns
	fake.recordInvocation("WaitForReady", []interface{}{arg1, arg2})
	fake.waitForReadyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCPI) WaitForReadyCallCount() int {
	fake.waitForReadyMutex.RLock()
	defer fake.waitForReadyMutex.RUnlock()
	return len(fake.waitForReadyArgsForCall)
}

func (fake *FakeCPI) WaitForReadyCalls(stub func(context.Context, time.Duration) error) {
	fake.waitForReadyMutex.Lock()
	defer fake.waitForReadyMutex.Unlock()
	fake.WaitForReadyStub = stub
}

func (fake *FakeCPI) WaitForReadyArgsForCall(i int) (context.Context, time.Duration) {
	fake.waitForReadyMutex.RLock()
	defer fake.waitForReadyMutex.RUnlock()
	argsForCall := fake.waitForReadyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCPI) WaitForReadyReturns(result1 error) {
	fake.waitForReadyMutex.Lock()
	defer fake.waitForReadyMutex.Unlock()
	fake.WaitForReadyStub = nil
	fake.waitForReadyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) WaitForReadyReturnsOnCall(i int, result1 error) {
	fake.waitForReadyMutex.Lock()
	defer fake.waitForReadyMutex.Unlock()
	fake.WaitForReadyStub = nil
	if fake.waitForReadyReturnsOnCall == nil {
		fake.waitForReadyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForReadyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cpi.CPI = new(FakeCPI)
