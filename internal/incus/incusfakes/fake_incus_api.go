// Code generated by counterfeiter. DO NOT EDIT.
package incusfakes

import (
	"io"
	"sync"

	incusa "github.com/lxc/incus/v6/client"
	"github.com/lxc/incus/v6/shared/api"
	"github.com/rkoster/instant-bosh/internal/incus"
)

type FakeIncusAPI struct {
	CopyImageStub        func(incusa.ImageServer, api.Image, *incusa.ImageCopyArgs) (incusa.RemoteOperation, error)
	copyImageMutex       sync.RWMutex
	copyImageArgsForCall []struct {
		arg1 incusa.ImageServer
		arg2 api.Image
		arg3 *incusa.ImageCopyArgs
	}
	copyImageReturns struct {
		result1 incusa.RemoteOperation
		result2 error
	}
	copyImageReturnsOnCall map[int]struct {
		result1 incusa.RemoteOperation
		result2 error
	}
	CreateImageStub        func(api.ImagesPost, *incusa.ImageCreateArgs) (incusa.Operation, error)
	createImageMutex       sync.RWMutex
	createImageArgsForCall []struct {
		arg1 api.ImagesPost
		arg2 *incusa.ImageCreateArgs
	}
	createImageReturns struct {
		result1 incusa.Operation
		result2 error
	}
	createImageReturnsOnCall map[int]struct {
		result1 incusa.Operation
		result2 error
	}
	CreateImageAliasStub        func(api.ImageAliasesPost) error
	createImageAliasMutex       sync.RWMutex
	createImageAliasArgsForCall []struct {
		arg1 api.ImageAliasesPost
	}
	createImageAliasReturns struct {
		result1 error
	}
	createImageAliasReturnsOnCall map[int]struct {
		result1 error
	}
	CreateInstanceStub        func(api.InstancesPost) (incusa.Operation, error)
	createInstanceMutex       sync.RWMutex
	createInstanceArgsForCall []struct {
		arg1 api.InstancesPost
	}
	createInstanceReturns struct {
		result1 incusa.Operation
		result2 error
	}
	createInstanceReturnsOnCall map[int]struct {
		result1 incusa.Operation
		result2 error
	}
	CreateInstanceFileStub        func(string, string, incusa.InstanceFileArgs) error
	createInstanceFileMutex       sync.RWMutex
	createInstanceFileArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 incusa.InstanceFileArgs
	}
	createInstanceFileReturns struct {
		result1 error
	}
	createInstanceFileReturnsOnCall map[int]struct {
		result1 error
	}
	CreateInstanceFromImageStub        func(incusa.ImageServer, api.Image, api.InstancesPost) (incusa.RemoteOperation, error)
	createInstanceFromImageMutex       sync.RWMutex
	createInstanceFromImageArgsForCall []struct {
		arg1 incusa.ImageServer
		arg2 api.Image
		arg3 api.InstancesPost
	}
	createInstanceFromImageReturns struct {
		result1 incusa.RemoteOperation
		result2 error
	}
	createInstanceFromImageReturnsOnCall map[int]struct {
		result1 incusa.RemoteOperation
		result2 error
	}
	CreateNetworkStub        func(api.NetworksPost) error
	createNetworkMutex       sync.RWMutex
	createNetworkArgsForCall []struct {
		arg1 api.NetworksPost
	}
	createNetworkReturns struct {
		result1 error
	}
	createNetworkReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteImageStub        func(string) (incusa.Operation, error)
	deleteImageMutex       sync.RWMutex
	deleteImageArgsForCall []struct {
		arg1 string
	}
	deleteImageReturns struct {
		result1 incusa.Operation
		result2 error
	}
	deleteImageReturnsOnCall map[int]struct {
		result1 incusa.Operation
		result2 error
	}
	DeleteInstanceStub        func(string) (incusa.Operation, error)
	deleteInstanceMutex       sync.RWMutex
	deleteInstanceArgsForCall []struct {
		arg1 string
	}
	deleteInstanceReturns struct {
		result1 incusa.Operation
		result2 error
	}
	deleteInstanceReturnsOnCall map[int]struct {
		result1 incusa.Operation
		result2 error
	}
	DeleteInstanceFileStub        func(string, string) error
	deleteInstanceFileMutex       sync.RWMutex
	deleteInstanceFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteInstanceFileReturns struct {
		result1 error
	}
	deleteInstanceFileReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteNetworkStub        func(string) error
	deleteNetworkMutex       sync.RWMutex
	deleteNetworkArgsForCall []struct {
		arg1 string
	}
	deleteNetworkReturns struct {
		result1 error
	}
	deleteNetworkReturnsOnCall map[int]struct {
		result1 error
	}
	DisconnectStub        func()
	disconnectMutex       sync.RWMutex
	disconnectArgsForCall []struct {
	}
	ExecInstanceStub        func(string, api.InstanceExecPost, *incusa.InstanceExecArgs) (incusa.Operation, error)
	execInstanceMutex       sync.RWMutex
	execInstanceArgsForCall []struct {
		arg1 string
		arg2 api.InstanceExecPost
		arg3 *incusa.InstanceExecArgs
	}
	execInstanceReturns struct {
		result1 incusa.Operation
		result2 error
	}
	execInstanceReturnsOnCall map[int]struct {
		result1 incusa.Operation
		result2 error
	}
	GetImageStub        func(string) (*api.Image, string, error)
	getImageMutex       sync.RWMutex
	getImageArgsForCall []struct {
		arg1 string
	}
	getImageReturns struct {
		result1 *api.Image
		result2 string
		result3 error
	}
	getImageReturnsOnCall map[int]struct {
		result1 *api.Image
		result2 string
		result3 error
	}
	GetImageAliasesStub        func() ([]api.ImageAliasesEntry, error)
	getImageAliasesMutex       sync.RWMutex
	getImageAliasesArgsForCall []struct {
	}
	getImageAliasesReturns struct {
		result1 []api.ImageAliasesEntry
		result2 error
	}
	getImageAliasesReturnsOnCall map[int]struct {
		result1 []api.ImageAliasesEntry
		result2 error
	}
	GetInstanceStub        func(string) (*api.Instance, string, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		arg1 string
	}
	getInstanceReturns struct {
		result1 *api.Instance
		result2 string
		result3 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 *api.Instance
		result2 string
		result3 error
	}
	GetInstanceFileStub        func(string, string) (io.ReadCloser, *incusa.InstanceFileResponse, error)
	getInstanceFileMutex       sync.RWMutex
	getInstanceFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getInstanceFileReturns struct {
		result1 io.ReadCloser
		result2 *incusa.InstanceFileResponse
		result3 error
	}
	getInstanceFileReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 *incusa.InstanceFileResponse
		result3 error
	}
	GetInstanceLogfileStub        func(string, string) (io.ReadCloser, error)
	getInstanceLogfileMutex       sync.RWMutex
	getInstanceLogfileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getInstanceLogfileReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	getInstanceLogfileReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	GetInstanceLogfilesStub        func(string) ([]string, error)
	getInstanceLogfilesMutex       sync.RWMutex
	getInstanceLogfilesArgsForCall []struct {
		arg1 string
	}
	getInstanceLogfilesReturns struct {
		result1 []string
		result2 error
	}
	getInstanceLogfilesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetInstancesStub        func(api.InstanceType) ([]api.Instance, error)
	getInstancesMutex       sync.RWMutex
	getInstancesArgsForCall []struct {
		arg1 api.InstanceType
	}
	getInstancesReturns struct {
		result1 []api.Instance
		result2 error
	}
	getInstancesReturnsOnCall map[int]struct {
		result1 []api.Instance
		result2 error
	}
	GetNetworkStub        func(string) (*api.Network, string, error)
	getNetworkMutex       sync.RWMutex
	getNetworkArgsForCall []struct {
		arg1 string
	}
	getNetworkReturns struct {
		result1 *api.Network
		result2 string
		result3 error
	}
	getNetworkReturnsOnCall map[int]struct {
		result1 *api.Network
		result2 string
		result3 error
	}
	GetNetworksStub        func() ([]api.Network, error)
	getNetworksMutex       sync.RWMutex
	getNetworksArgsForCall []struct {
	}
	getNetworksReturns struct {
		result1 []api.Network
		result2 error
	}
	getNetworksReturnsOnCall map[int]struct {
		result1 []api.Network
		result2 error
	}
	GetProfileStub        func(string) (*api.Profile, string, error)
	getProfileMutex       sync.RWMutex
	getProfileArgsForCall []struct {
		arg1 string
	}
	getProfileReturns struct {
		result1 *api.Profile
		result2 string
		result3 error
	}
	getProfileReturnsOnCall map[int]struct {
		result1 *api.Profile
		result2 string
		result3 error
	}
	GetServerStub        func() (*api.Server, string, error)
	getServerMutex       sync.RWMutex
	getServerArgsForCall []struct {
	}
	getServerReturns struct {
		result1 *api.Server
		result2 string
		result3 error
	}
	getServerReturnsOnCall map[int]struct {
		result1 *api.Server
		result2 string
		result3 error
	}
	GetStoragePoolStub        func(string) (*api.StoragePool, string, error)
	getStoragePoolMutex       sync.RWMutex
	getStoragePoolArgsForCall []struct {
		arg1 string
	}
	getStoragePoolReturns struct {
		result1 *api.StoragePool
		result2 string
		result3 error
	}
	getStoragePoolReturnsOnCall map[int]struct {
		result1 *api.StoragePool
		result2 string
		result3 error
	}
	GetStoragePoolsStub        func() ([]api.StoragePool, error)
	getStoragePoolsMutex       sync.RWMutex
	getStoragePoolsArgsForCall []struct {
	}
	getStoragePoolsReturns struct {
		result1 []api.StoragePool
		result2 error
	}
	getStoragePoolsReturnsOnCall map[int]struct {
		result1 []api.StoragePool
		result2 error
	}
	UpdateInstanceStateStub        func(string, api.InstanceStatePut, string) (incusa.Operation, error)
	updateInstanceStateMutex       sync.RWMutex
	updateInstanceStateArgsForCall []struct {
		arg1 string
		arg2 api.InstanceStatePut
		arg3 string
	}
	updateInstanceStateReturns struct {
		result1 incusa.Operation
		result2 error
	}
	updateInstanceStateReturnsOnCall map[int]struct {
		result1 incusa.Operation
		result2 error
	}
	UseProjectStub        func(string) incusa.InstanceServer
	useProjectMutex       sync.RWMutex
	useProjectArgsForCall []struct {
		arg1 string
	}
	useProjectReturns struct {
		result1 incusa.InstanceServer
	}
	useProjectReturnsOnCall map[int]struct {
		result1 incusa.InstanceServer
	}
	UseTargetStub        func(string) incusa.InstanceServer
	useTargetMutex       sync.RWMutex
	useTargetArgsForCall []struct {
		arg1 string
	}
	useTargetReturns struct {
		result1 incusa.InstanceServer
	}
	useTargetReturnsOnCall map[int]struct {
		result1 incusa.InstanceServer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIncusAPI) CopyImage(arg1 incusa.ImageServer, arg2 api.Image, arg3 *incusa.ImageCopyArgs) (incusa.RemoteOperation, error) {
	fake.copyImageMutex.Lock()
	ret, specificReturn := fake.copyImageReturnsOnCall[len(fake.copyImageArgsForCall)]
	fake.copyImageArgsForCall = append(fake.copyImageArgsForCall, struct {
		arg1 incusa.ImageServer
		arg2 api.Image
		arg3 *incusa.ImageCopyArgs
	}{arg1, arg2, arg3})
	stub := fake.CopyImageStub
	fakeReturns := fake.copyImageReturns
	fake.recordInvocation("CopyImage", []interface{}{arg1, arg2, arg3})
	fake.copyImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) CopyImageCallCount() int {
	fake.copyImageMutex.RLock()
	defer fake.copyImageMutex.RUnlock()
	return len(fake.copyImageArgsForCall)
}

func (fake *FakeIncusAPI) CopyImageCalls(stub func(incusa.ImageServer, api.Image, *incusa.ImageCopyArgs) (incusa.RemoteOperation, error)) {
	fake.copyImageMutex.Lock()
	defer fake.copyImageMutex.Unlock()
	fake.CopyImageStub = stub
}

func (fake *FakeIncusAPI) CopyImageArgsForCall(i int) (incusa.ImageServer, api.Image, *incusa.ImageCopyArgs) {
	fake.copyImageMutex.RLock()
	defer fake.copyImageMutex.RUnlock()
	argsForCall := fake.copyImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIncusAPI) CopyImageReturns(result1 incusa.RemoteOperation, result2 error) {
	fake.copyImageMutex.Lock()
	defer fake.copyImageMutex.Unlock()
	fake.CopyImageStub = nil
	fake.copyImageReturns = struct {
		result1 incusa.RemoteOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CopyImageReturnsOnCall(i int, result1 incusa.RemoteOperation, result2 error) {
	fake.copyImageMutex.Lock()
	defer fake.copyImageMutex.Unlock()
	fake.CopyImageStub = nil
	if fake.copyImageReturnsOnCall == nil {
		fake.copyImageReturnsOnCall = make(map[int]struct {
			result1 incusa.RemoteOperation
			result2 error
		})
	}
	fake.copyImageReturnsOnCall[i] = struct {
		result1 incusa.RemoteOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateImage(arg1 api.ImagesPost, arg2 *incusa.ImageCreateArgs) (incusa.Operation, error) {
	fake.createImageMutex.Lock()
	ret, specificReturn := fake.createImageReturnsOnCall[len(fake.createImageArgsForCall)]
	fake.createImageArgsForCall = append(fake.createImageArgsForCall, struct {
		arg1 api.ImagesPost
		arg2 *incusa.ImageCreateArgs
	}{arg1, arg2})
	stub := fake.CreateImageStub
	fakeReturns := fake.createImageReturns
	fake.recordInvocation("CreateImage", []interface{}{arg1, arg2})
	fake.createImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) CreateImageCallCount() int {
	fake.createImageMutex.RLock()
	defer fake.createImageMutex.RUnlock()
	return len(fake.createImageArgsForCall)
}

func (fake *FakeIncusAPI) CreateImageCalls(stub func(api.ImagesPost, *incusa.ImageCreateArgs) (incusa.Operation, error)) {
	fake.createImageMutex.Lock()
	defer fake.createImageMutex.Unlock()
	fake.CreateImageStub = stub
}

func (fake *FakeIncusAPI) CreateImageArgsForCall(i int) (api.ImagesPost, *incusa.ImageCreateArgs) {
	fake.createImageMutex.RLock()
	defer fake.createImageMutex.RUnlock()
	argsForCall := fake.createImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIncusAPI) CreateImageReturns(result1 incusa.Operation, result2 error) {
	fake.createImageMutex.Lock()
	defer fake.createImageMutex.Unlock()
	fake.CreateImageStub = nil
	fake.createImageReturns = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateImageReturnsOnCall(i int, result1 incusa.Operation, result2 error) {
	fake.createImageMutex.Lock()
	defer fake.createImageMutex.Unlock()
	fake.CreateImageStub = nil
	if fake.createImageReturnsOnCall == nil {
		fake.createImageReturnsOnCall = make(map[int]struct {
			result1 incusa.Operation
			result2 error
		})
	}
	fake.createImageReturnsOnCall[i] = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateImageAlias(arg1 api.ImageAliasesPost) error {
	fake.createImageAliasMutex.Lock()
	ret, specificReturn := fake.createImageAliasReturnsOnCall[len(fake.createImageAliasArgsForCall)]
	fake.createImageAliasArgsForCall = append(fake.createImageAliasArgsForCall, struct {
		arg1 api.ImageAliasesPost
	}{arg1})
	stub := fake.CreateImageAliasStub
	fakeReturns := fake.createImageAliasReturns
	fake.recordInvocation("CreateImageAlias", []interface{}{arg1})
	fake.createImageAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) CreateImageAliasCallCount() int {
	fake.createImageAliasMutex.RLock()
	defer fake.createImageAliasMutex.RUnlock()
	return len(fake.createImageAliasArgsForCall)
}

func (fake *FakeIncusAPI) CreateImageAliasCalls(stub func(api.ImageAliasesPost) error) {
	fake.createImageAliasMutex.Lock()
	defer fake.createImageAliasMutex.Unlock()
	fake.CreateImageAliasStub = stub
}

func (fake *FakeIncusAPI) CreateImageAliasArgsForCall(i int) api.ImageAliasesPost {
	fake.createImageAliasMutex.RLock()
	defer fake.createImageAliasMutex.RUnlock()
	argsForCall := fake.createImageAliasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) CreateImageAliasReturns(result1 error) {
	fake.createImageAliasMutex.Lock()
	defer fake.createImageAliasMutex.Unlock()
	fake.CreateImageAliasStub = nil
	fake.createImageAliasReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) CreateImageAliasReturnsOnCall(i int, result1 error) {
	fake.createImageAliasMutex.Lock()
	defer fake.createImageAliasMutex.Unlock()
	fake.CreateImageAliasStub = nil
	if fake.createImageAliasReturnsOnCall == nil {
		fake.createImageAliasReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createImageAliasReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) CreateInstance(arg1 api.InstancesPost) (incusa.Operation, error) {
	fake.createInstanceMutex.Lock()
	ret, specificReturn := fake.createInstanceReturnsOnCall[len(fake.createInstanceArgsForCall)]
	fake.createInstanceArgsForCall = append(fake.createInstanceArgsForCall, struct {
		arg1 api.InstancesPost
	}{arg1})
	stub := fake.CreateInstanceStub
	fakeReturns := fake.createInstanceReturns
	fake.recordInvocation("CreateInstance", []interface{}{arg1})
	fake.createInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) CreateInstanceCallCount() int {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return len(fake.createInstanceArgsForCall)
}

func (fake *FakeIncusAPI) CreateInstanceCalls(stub func(api.InstancesPost) (incusa.Operation, error)) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = stub
}

func (fake *FakeIncusAPI) CreateInstanceArgsForCall(i int) api.InstancesPost {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	argsForCall := fake.createInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) CreateInstanceReturns(result1 incusa.Operation, result2 error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = nil
	fake.createInstanceReturns = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateInstanceReturnsOnCall(i int, result1 incusa.Operation, result2 error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = nil
	if fake.createInstanceReturnsOnCall == nil {
		fake.createInstanceReturnsOnCall = make(map[int]struct {
			result1 incusa.Operation
			result2 error
		})
	}
	fake.createInstanceReturnsOnCall[i] = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateInstanceFile(arg1 string, arg2 string, arg3 incusa.InstanceFileArgs) error {
	fake.createInstanceFileMutex.Lock()
	ret, specificReturn := fake.createInstanceFileReturnsOnCall[len(fake.createInstanceFileArgsForCall)]
	fake.createInstanceFileArgsForCall = append(fake.createInstanceFileArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 incusa.InstanceFileArgs
	}{arg1, arg2, arg3})
	stub := fake.CreateInstanceFileStub
	fakeReturns := fake.createInstanceFileReturns
	fake.recordInvocation("CreateInstanceFile", []interface{}{arg1, arg2, arg3})
	fake.createInstanceFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) CreateInstanceFileCallCount() int {
	fake.createInstanceFileMutex.RLock()
	defer fake.createInstanceFileMutex.RUnlock()
	return len(fake.createInstanceFileArgsForCall)
}

func (fake *FakeIncusAPI) CreateInstanceFileCalls(stub func(string, string, incusa.InstanceFileArgs) error) {
	fake.createInstanceFileMutex.Lock()
	defer fake.createInstanceFileMutex.Unlock()
	fake.CreateInstanceFileStub = stub
}

func (fake *FakeIncusAPI) CreateInstanceFileArgsForCall(i int) (string, string, incusa.InstanceFileArgs) {
	fake.createInstanceFileMutex.RLock()
	defer fake.createInstanceFileMutex.RUnlock()
	argsForCall := fake.createInstanceFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIncusAPI) CreateInstanceFileReturns(result1 error) {
	fake.createInstanceFileMutex.Lock()
	defer fake.createInstanceFileMutex.Unlock()
	fake.CreateInstanceFileStub = nil
	fake.createInstanceFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) CreateInstanceFileReturnsOnCall(i int, result1 error) {
	fake.createInstanceFileMutex.Lock()
	defer fake.createInstanceFileMutex.Unlock()
	fake.CreateInstanceFileStub = nil
	if fake.createInstanceFileReturnsOnCall == nil {
		fake.createInstanceFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createInstanceFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) CreateInstanceFromImage(arg1 incusa.ImageServer, arg2 api.Image, arg3 api.InstancesPost) (incusa.RemoteOperation, error) {
	fake.createInstanceFromImageMutex.Lock()
	ret, specificReturn := fake.createInstanceFromImageReturnsOnCall[len(fake.createInstanceFromImageArgsForCall)]
	fake.createInstanceFromImageArgsForCall = append(fake.createInstanceFromImageArgsForCall, struct {
		arg1 incusa.ImageServer
		arg2 api.Image
		arg3 api.InstancesPost
	}{arg1, arg2, arg3})
	stub := fake.CreateInstanceFromImageStub
	fakeReturns := fake.createInstanceFromImageReturns
	fake.recordInvocation("CreateInstanceFromImage", []interface{}{arg1, arg2, arg3})
	fake.createInstanceFromImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) CreateInstanceFromImageCallCount() int {
	fake.createInstanceFromImageMutex.RLock()
	defer fake.createInstanceFromImageMutex.RUnlock()
	return len(fake.createInstanceFromImageArgsForCall)
}

func (fake *FakeIncusAPI) CreateInstanceFromImageCalls(stub func(incusa.ImageServer, api.Image, api.InstancesPost) (incusa.RemoteOperation, error)) {
	fake.createInstanceFromImageMutex.Lock()
	defer fake.createInstanceFromImageMutex.Unlock()
	fake.CreateInstanceFromImageStub = stub
}

func (fake *FakeIncusAPI) CreateInstanceFromImageArgsForCall(i int) (incusa.ImageServer, api.Image, api.InstancesPost) {
	fake.createInstanceFromImageMutex.RLock()
	defer fake.createInstanceFromImageMutex.RUnlock()
	argsForCall := fake.createInstanceFromImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIncusAPI) CreateInstanceFromImageReturns(result1 incusa.RemoteOperation, result2 error) {
	fake.createInstanceFromImageMutex.Lock()
	defer fake.createInstanceFromImageMutex.Unlock()
	fake.CreateInstanceFromImageStub = nil
	fake.createInstanceFromImageReturns = struct {
		result1 incusa.RemoteOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateInstanceFromImageReturnsOnCall(i int, result1 incusa.RemoteOperation, result2 error) {
	fake.createInstanceFromImageMutex.Lock()
	defer fake.createInstanceFromImageMutex.Unlock()
	fake.CreateInstanceFromImageStub = nil
	if fake.createInstanceFromImageReturnsOnCall == nil {
		fake.createInstanceFromImageReturnsOnCall = make(map[int]struct {
			result1 incusa.RemoteOperation
			result2 error
		})
	}
	fake.createInstanceFromImageReturnsOnCall[i] = struct {
		result1 incusa.RemoteOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) CreateNetwork(arg1 api.NetworksPost) error {
	fake.createNetworkMutex.Lock()
	ret, specificReturn := fake.createNetworkReturnsOnCall[len(fake.createNetworkArgsForCall)]
	fake.createNetworkArgsForCall = append(fake.createNetworkArgsForCall, struct {
		arg1 api.NetworksPost
	}{arg1})
	stub := fake.CreateNetworkStub
	fakeReturns := fake.createNetworkReturns
	fake.recordInvocation("CreateNetwork", []interface{}{arg1})
	fake.createNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) CreateNetworkCallCount() int {
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	return len(fake.createNetworkArgsForCall)
}

func (fake *FakeIncusAPI) CreateNetworkCalls(stub func(api.NetworksPost) error) {
	fake.createNetworkMutex.Lock()
	defer fake.createNetworkMutex.Unlock()
	fake.CreateNetworkStub = stub
}

func (fake *FakeIncusAPI) CreateNetworkArgsForCall(i int) api.NetworksPost {
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	argsForCall := fake.createNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) CreateNetworkReturns(result1 error) {
	fake.createNetworkMutex.Lock()
	defer fake.createNetworkMutex.Unlock()
	fake.CreateNetworkStub = nil
	fake.createNetworkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) CreateNetworkReturnsOnCall(i int, result1 error) {
	fake.createNetworkMutex.Lock()
	defer fake.createNetworkMutex.Unlock()
	fake.CreateNetworkStub = nil
	if fake.createNetworkReturnsOnCall == nil {
		fake.createNetworkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createNetworkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) DeleteImage(arg1 string) (incusa.Operation, error) {
	fake.deleteImageMutex.Lock()
	ret, specificReturn := fake.deleteImageReturnsOnCall[len(fake.deleteImageArgsForCall)]
	fake.deleteImageArgsForCall = append(fake.deleteImageArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteImageStub
	fakeReturns := fake.deleteImageReturns
	fake.recordInvocation("DeleteImage", []interface{}{arg1})
	fake.deleteImageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) DeleteImageCallCount() int {
	fake.deleteImageMutex.RLock()
	defer fake.deleteImageMutex.RUnlock()
	return len(fake.deleteImageArgsForCall)
}

func (fake *FakeIncusAPI) DeleteImageCalls(stub func(string) (incusa.Operation, error)) {
	fake.deleteImageMutex.Lock()
	defer fake.deleteImageMutex.Unlock()
	fake.DeleteImageStub = stub
}

func (fake *FakeIncusAPI) DeleteImageArgsForCall(i int) string {
	fake.deleteImageMutex.RLock()
	defer fake.deleteImageMutex.RUnlock()
	argsForCall := fake.deleteImageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) DeleteImageReturns(result1 incusa.Operation, result2 error) {
	fake.deleteImageMutex.Lock()
	defer fake.deleteImageMutex.Unlock()
	fake.DeleteImageStub = nil
	fake.deleteImageReturns = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) DeleteImageReturnsOnCall(i int, result1 incusa.Operation, result2 error) {
	fake.deleteImageMutex.Lock()
	defer fake.deleteImageMutex.Unlock()
	fake.DeleteImageStub = nil
	if fake.deleteImageReturnsOnCall == nil {
		fake.deleteImageReturnsOnCall = make(map[int]struct {
			result1 incusa.Operation
			result2 error
		})
	}
	fake.deleteImageReturnsOnCall[i] = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) DeleteInstance(arg1 string) (incusa.Operation, error) {
	fake.deleteInstanceMutex.Lock()
	ret, specificReturn := fake.deleteInstanceReturnsOnCall[len(fake.deleteInstanceArgsForCall)]
	fake.deleteInstanceArgsForCall = append(fake.deleteInstanceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteInstanceStub
	fakeReturns := fake.deleteInstanceReturns
	fake.recordInvocation("DeleteInstance", []interface{}{arg1})
	fake.deleteInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) DeleteInstanceCallCount() int {
	fake.deleteInstanceMutex.RLock()
	defer fake.deleteInstanceMutex.RUnlock()
	return len(fake.deleteInstanceArgsForCall)
}

func (fake *FakeIncusAPI) DeleteInstanceCalls(stub func(string) (incusa.Operation, error)) {
	fake.deleteInstanceMutex.Lock()
	defer fake.deleteInstanceMutex.Unlock()
	fake.DeleteInstanceStub = stub
}

func (fake *FakeIncusAPI) DeleteInstanceArgsForCall(i int) string {
	fake.deleteInstanceMutex.RLock()
	defer fake.deleteInstanceMutex.RUnlock()
	argsForCall := fake.deleteInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) DeleteInstanceReturns(result1 incusa.Operation, result2 error) {
	fake.deleteInstanceMutex.Lock()
	defer fake.deleteInstanceMutex.Unlock()
	fake.DeleteInstanceStub = nil
	fake.deleteInstanceReturns = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) DeleteInstanceReturnsOnCall(i int, result1 incusa.Operation, result2 error) {
	fake.deleteInstanceMutex.Lock()
	defer fake.deleteInstanceMutex.Unlock()
	fake.DeleteInstanceStub = nil
	if fake.deleteInstanceReturnsOnCall == nil {
		fake.deleteInstanceReturnsOnCall = make(map[int]struct {
			result1 incusa.Operation
			result2 error
		})
	}
	fake.deleteInstanceReturnsOnCall[i] = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) DeleteInstanceFile(arg1 string, arg2 string) error {
	fake.deleteInstanceFileMutex.Lock()
	ret, specificReturn := fake.deleteInstanceFileReturnsOnCall[len(fake.deleteInstanceFileArgsForCall)]
	fake.deleteInstanceFileArgsForCall = append(fake.deleteInstanceFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteInstanceFileStub
	fakeReturns := fake.deleteInstanceFileReturns
	fake.recordInvocation("DeleteInstanceFile", []interface{}{arg1, arg2})
	fake.deleteInstanceFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) DeleteInstanceFileCallCount() int {
	fake.deleteInstanceFileMutex.RLock()
	defer fake.deleteInstanceFileMutex.RUnlock()
	return len(fake.deleteInstanceFileArgsForCall)
}

func (fake *FakeIncusAPI) DeleteInstanceFileCalls(stub func(string, string) error) {
	fake.deleteInstanceFileMutex.Lock()
	defer fake.deleteInstanceFileMutex.Unlock()
	fake.DeleteInstanceFileStub = stub
}

func (fake *FakeIncusAPI) DeleteInstanceFileArgsForCall(i int) (string, string) {
	fake.deleteInstanceFileMutex.RLock()
	defer fake.deleteInstanceFileMutex.RUnlock()
	argsForCall := fake.deleteInstanceFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIncusAPI) DeleteInstanceFileReturns(result1 error) {
	fake.deleteInstanceFileMutex.Lock()
	defer fake.deleteInstanceFileMutex.Unlock()
	fake.DeleteInstanceFileStub = nil
	fake.deleteInstanceFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) DeleteInstanceFileReturnsOnCall(i int, result1 error) {
	fake.deleteInstanceFileMutex.Lock()
	defer fake.deleteInstanceFileMutex.Unlock()
	fake.DeleteInstanceFileStub = nil
	if fake.deleteInstanceFileReturnsOnCall == nil {
		fake.deleteInstanceFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteInstanceFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) DeleteNetwork(arg1 string) error {
	fake.deleteNetworkMutex.Lock()
	ret, specificReturn := fake.deleteNetworkReturnsOnCall[len(fake.deleteNetworkArgsForCall)]
	fake.deleteNetworkArgsForCall = append(fake.deleteNetworkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteNetworkStub
	fakeReturns := fake.deleteNetworkReturns
	fake.recordInvocation("DeleteNetwork", []interface{}{arg1})
	fake.deleteNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) DeleteNetworkCallCount() int {
	fake.deleteNetworkMutex.RLock()
	defer fake.deleteNetworkMutex.RUnlock()
	return len(fake.deleteNetworkArgsForCall)
}

func (fake *FakeIncusAPI) DeleteNetworkCalls(stub func(string) error) {
	fake.deleteNetworkMutex.Lock()
	defer fake.deleteNetworkMutex.Unlock()
	fake.DeleteNetworkStub = stub
}

func (fake *FakeIncusAPI) DeleteNetworkArgsForCall(i int) string {
	fake.deleteNetworkMutex.RLock()
	defer fake.deleteNetworkMutex.RUnlock()
	argsForCall := fake.deleteNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) DeleteNetworkReturns(result1 error) {
	fake.deleteNetworkMutex.Lock()
	defer fake.deleteNetworkMutex.Unlock()
	fake.DeleteNetworkStub = nil
	fake.deleteNetworkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) DeleteNetworkReturnsOnCall(i int, result1 error) {
	fake.deleteNetworkMutex.Lock()
	defer fake.deleteNetworkMutex.Unlock()
	fake.DeleteNetworkStub = nil
	if fake.deleteNetworkReturnsOnCall == nil {
		fake.deleteNetworkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNetworkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIncusAPI) Disconnect() {
	fake.disconnectMutex.Lock()
	fake.disconnectArgsForCall = append(fake.disconnectArgsForCall, struct {
	}{})
	stub := fake.DisconnectStub
	fake.recordInvocation("Disconnect", []interface{}{})
	fake.disconnectMutex.Unlock()
	if stub != nil {
		fake.DisconnectStub()
	}
}

func (fake *FakeIncusAPI) DisconnectCallCount() int {
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	return len(fake.disconnectArgsForCall)
}

func (fake *FakeIncusAPI) DisconnectCalls(stub func()) {
	fake.disconnectMutex.Lock()
	defer fake.disconnectMutex.Unlock()
	fake.DisconnectStub = stub
}

func (fake *FakeIncusAPI) ExecInstance(arg1 string, arg2 api.InstanceExecPost, arg3 *incusa.InstanceExecArgs) (incusa.Operation, error) {
	fake.execInstanceMutex.Lock()
	ret, specificReturn := fake.execInstanceReturnsOnCall[len(fake.execInstanceArgsForCall)]
	fake.execInstanceArgsForCall = append(fake.execInstanceArgsForCall, struct {
		arg1 string
		arg2 api.InstanceExecPost
		arg3 *incusa.InstanceExecArgs
	}{arg1, arg2, arg3})
	stub := fake.ExecInstanceStub
	fakeReturns := fake.execInstanceReturns
	fake.recordInvocation("ExecInstance", []interface{}{arg1, arg2, arg3})
	fake.execInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) ExecInstanceCallCount() int {
	fake.execInstanceMutex.RLock()
	defer fake.execInstanceMutex.RUnlock()
	return len(fake.execInstanceArgsForCall)
}

func (fake *FakeIncusAPI) ExecInstanceCalls(stub func(string, api.InstanceExecPost, *incusa.InstanceExecArgs) (incusa.Operation, error)) {
	fake.execInstanceMutex.Lock()
	defer fake.execInstanceMutex.Unlock()
	fake.ExecInstanceStub = stub
}

func (fake *FakeIncusAPI) ExecInstanceArgsForCall(i int) (string, api.InstanceExecPost, *incusa.InstanceExecArgs) {
	fake.execInstanceMutex.RLock()
	defer fake.execInstanceMutex.RUnlock()
	argsForCall := fake.execInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIncusAPI) ExecInstanceReturns(result1 incusa.Operation, result2 error) {
	fake.execInstanceMutex.Lock()
	defer fake.execInstanceMutex.Unlock()
	fake.ExecInstanceStub = nil
	fake.execInstanceReturns = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) ExecInstanceReturnsOnCall(i int, result1 incusa.Operation, result2 error) {
	fake.execInstanceMutex.Lock()
	defer fake.execInstanceMutex.Unlock()
	fake.ExecInstanceStub = nil
	if fake.execInstanceReturnsOnCall == nil {
		fake.execInstanceReturnsOnCall = make(map[int]struct {
			result1 incusa.Operation
			result2 error
		})
	}
	fake.execInstanceReturnsOnCall[i] = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetImage(arg1 string) (*api.Image, string, error) {
	fake.getImageMutex.Lock()
	ret, specificReturn := fake.getImageReturnsOnCall[len(fake.getImageArgsForCall)]
	fake.getImageArgsForCall = append(fake.getImageArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetImageStub
	fakeReturns := fake.getImageReturns
	fake.recordInvocation("GetImage", []interface{}{arg1})
	fake.getImageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetImageCallCount() int {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return len(fake.getImageArgsForCall)
}

func (fake *FakeIncusAPI) GetImageCalls(stub func(string) (*api.Image, string, error)) {
	fake.getImageMutex.Lock()
	defer fake.getImageMutex.Unlock()
	fake.GetImageStub = stub
}

func (fake *FakeIncusAPI) GetImageArgsForCall(i int) string {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	argsForCall := fake.getImageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetImageReturns(result1 *api.Image, result2 string, result3 error) {
	fake.getImageMutex.Lock()
	defer fake.getImageMutex.Unlock()
	fake.GetImageStub = nil
	fake.getImageReturns = struct {
		result1 *api.Image
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetImageReturnsOnCall(i int, result1 *api.Image, result2 string, result3 error) {
	fake.getImageMutex.Lock()
	defer fake.getImageMutex.Unlock()
	fake.GetImageStub = nil
	if fake.getImageReturnsOnCall == nil {
		fake.getImageReturnsOnCall = make(map[int]struct {
			result1 *api.Image
			result2 string
			result3 error
		})
	}
	fake.getImageReturnsOnCall[i] = struct {
		result1 *api.Image
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetImageAliases() ([]api.ImageAliasesEntry, error) {
	fake.getImageAliasesMutex.Lock()
	ret, specificReturn := fake.getImageAliasesReturnsOnCall[len(fake.getImageAliasesArgsForCall)]
	fake.getImageAliasesArgsForCall = append(fake.getImageAliasesArgsForCall, struct {
	}{})
	stub := fake.GetImageAliasesStub
	fakeReturns := fake.getImageAliasesReturns
	fake.recordInvocation("GetImageAliases", []interface{}{})
	fake.getImageAliasesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) GetImageAliasesCallCount() int {
	fake.getImageAliasesMutex.RLock()
	defer fake.getImageAliasesMutex.RUnlock()
	return len(fake.getImageAliasesArgsForCall)
}

func (fake *FakeIncusAPI) GetImageAliasesCalls(stub func() ([]api.ImageAliasesEntry, error)) {
	fake.getImageAliasesMutex.Lock()
	defer fake.getImageAliasesMutex.Unlock()
	fake.GetImageAliasesStub = stub
}

func (fake *FakeIncusAPI) GetImageAliasesReturns(result1 []api.ImageAliasesEntry, result2 error) {
	fake.getImageAliasesMutex.Lock()
	defer fake.getImageAliasesMutex.Unlock()
	fake.GetImageAliasesStub = nil
	fake.getImageAliasesReturns = struct {
		result1 []api.ImageAliasesEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetImageAliasesReturnsOnCall(i int, result1 []api.ImageAliasesEntry, result2 error) {
	fake.getImageAliasesMutex.Lock()
	defer fake.getImageAliasesMutex.Unlock()
	fake.GetImageAliasesStub = nil
	if fake.getImageAliasesReturnsOnCall == nil {
		fake.getImageAliasesReturnsOnCall = make(map[int]struct {
			result1 []api.ImageAliasesEntry
			result2 error
		})
	}
	fake.getImageAliasesReturnsOnCall[i] = struct {
		result1 []api.ImageAliasesEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetInstance(arg1 string) (*api.Instance, string, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetInstanceStub
	fakeReturns := fake.getInstanceReturns
	fake.recordInvocation("GetInstance", []interface{}{arg1})
	fake.getInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeIncusAPI) GetInstanceCalls(stub func(string) (*api.Instance, string, error)) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = stub
}

func (fake *FakeIncusAPI) GetInstanceArgsForCall(i int) string {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	argsForCall := fake.getInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetInstanceReturns(result1 *api.Instance, result2 string, result3 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 *api.Instance
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetInstanceReturnsOnCall(i int, result1 *api.Instance, result2 string, result3 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 *api.Instance
			result2 string
			result3 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 *api.Instance
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetInstanceFile(arg1 string, arg2 string) (io.ReadCloser, *incusa.InstanceFileResponse, error) {
	fake.getInstanceFileMutex.Lock()
	ret, specificReturn := fake.getInstanceFileReturnsOnCall[len(fake.getInstanceFileArgsForCall)]
	fake.getInstanceFileArgsForCall = append(fake.getInstanceFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetInstanceFileStub
	fakeReturns := fake.getInstanceFileReturns
	fake.recordInvocation("GetInstanceFile", []interface{}{arg1, arg2})
	fake.getInstanceFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetInstanceFileCallCount() int {
	fake.getInstanceFileMutex.RLock()
	defer fake.getInstanceFileMutex.RUnlock()
	return len(fake.getInstanceFileArgsForCall)
}

func (fake *FakeIncusAPI) GetInstanceFileCalls(stub func(string, string) (io.ReadCloser, *incusa.InstanceFileResponse, error)) {
	fake.getInstanceFileMutex.Lock()
	defer fake.getInstanceFileMutex.Unlock()
	fake.GetInstanceFileStub = stub
}

func (fake *FakeIncusAPI) GetInstanceFileArgsForCall(i int) (string, string) {
	fake.getInstanceFileMutex.RLock()
	defer fake.getInstanceFileMutex.RUnlock()
	argsForCall := fake.getInstanceFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIncusAPI) GetInstanceFileReturns(result1 io.ReadCloser, result2 *incusa.InstanceFileResponse, result3 error) {
	fake.getInstanceFileMutex.Lock()
	defer fake.getInstanceFileMutex.Unlock()
	fake.GetInstanceFileStub = nil
	fake.getInstanceFileReturns = struct {
		result1 io.ReadCloser
		result2 *incusa.InstanceFileResponse
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetInstanceFileReturnsOnCall(i int, result1 io.ReadCloser, result2 *incusa.InstanceFileResponse, result3 error) {
	fake.getInstanceFileMutex.Lock()
	defer fake.getInstanceFileMutex.Unlock()
	fake.GetInstanceFileStub = nil
	if fake.getInstanceFileReturnsOnCall == nil {
		fake.getInstanceFileReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 *incusa.InstanceFileResponse
			result3 error
		})
	}
	fake.getInstanceFileReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 *incusa.InstanceFileResponse
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetInstanceLogfile(arg1 string, arg2 string) (io.ReadCloser, error) {
	fake.getInstanceLogfileMutex.Lock()
	ret, specificReturn := fake.getInstanceLogfileReturnsOnCall[len(fake.getInstanceLogfileArgsForCall)]
	fake.getInstanceLogfileArgsForCall = append(fake.getInstanceLogfileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetInstanceLogfileStub
	fakeReturns := fake.getInstanceLogfileReturns
	fake.recordInvocation("GetInstanceLogfile", []interface{}{arg1, arg2})
	fake.getInstanceLogfileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) GetInstanceLogfileCallCount() int {
	fake.getInstanceLogfileMutex.RLock()
	defer fake.getInstanceLogfileMutex.RUnlock()
	return len(fake.getInstanceLogfileArgsForCall)
}

func (fake *FakeIncusAPI) GetInstanceLogfileCalls(stub func(string, string) (io.ReadCloser, error)) {
	fake.getInstanceLogfileMutex.Lock()
	defer fake.getInstanceLogfileMutex.Unlock()
	fake.GetInstanceLogfileStub = stub
}

func (fake *FakeIncusAPI) GetInstanceLogfileArgsForCall(i int) (string, string) {
	fake.getInstanceLogfileMutex.RLock()
	defer fake.getInstanceLogfileMutex.RUnlock()
	argsForCall := fake.getInstanceLogfileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIncusAPI) GetInstanceLogfileReturns(result1 io.ReadCloser, result2 error) {
	fake.getInstanceLogfileMutex.Lock()
	defer fake.getInstanceLogfileMutex.Unlock()
	fake.GetInstanceLogfileStub = nil
	fake.getInstanceLogfileReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetInstanceLogfileReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.getInstanceLogfileMutex.Lock()
	defer fake.getInstanceLogfileMutex.Unlock()
	fake.GetInstanceLogfileStub = nil
	if fake.getInstanceLogfileReturnsOnCall == nil {
		fake.getInstanceLogfileReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.getInstanceLogfileReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetInstanceLogfiles(arg1 string) ([]string, error) {
	fake.getInstanceLogfilesMutex.Lock()
	ret, specificReturn := fake.getInstanceLogfilesReturnsOnCall[len(fake.getInstanceLogfilesArgsForCall)]
	fake.getInstanceLogfilesArgsForCall = append(fake.getInstanceLogfilesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetInstanceLogfilesStub
	fakeReturns := fake.getInstanceLogfilesReturns
	fake.recordInvocation("GetInstanceLogfiles", []interface{}{arg1})
	fake.getInstanceLogfilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) GetInstanceLogfilesCallCount() int {
	fake.getInstanceLogfilesMutex.RLock()
	defer fake.getInstanceLogfilesMutex.RUnlock()
	return len(fake.getInstanceLogfilesArgsForCall)
}

func (fake *FakeIncusAPI) GetInstanceLogfilesCalls(stub func(string) ([]string, error)) {
	fake.getInstanceLogfilesMutex.Lock()
	defer fake.getInstanceLogfilesMutex.Unlock()
	fake.GetInstanceLogfilesStub = stub
}

func (fake *FakeIncusAPI) GetInstanceLogfilesArgsForCall(i int) string {
	fake.getInstanceLogfilesMutex.RLock()
	defer fake.getInstanceLogfilesMutex.RUnlock()
	argsForCall := fake.getInstanceLogfilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetInstanceLogfilesReturns(result1 []string, result2 error) {
	fake.getInstanceLogfilesMutex.Lock()
	defer fake.getInstanceLogfilesMutex.Unlock()
	fake.GetInstanceLogfilesStub = nil
	fake.getInstanceLogfilesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetInstanceLogfilesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getInstanceLogfilesMutex.Lock()
	defer fake.getInstanceLogfilesMutex.Unlock()
	fake.GetInstanceLogfilesStub = nil
	if fake.getInstanceLogfilesReturnsOnCall == nil {
		fake.getInstanceLogfilesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getInstanceLogfilesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetInstances(arg1 api.InstanceType) ([]api.Instance, error) {
	fake.getInstancesMutex.Lock()
	ret, specificReturn := fake.getInstancesReturnsOnCall[len(fake.getInstancesArgsForCall)]
	fake.getInstancesArgsForCall = append(fake.getInstancesArgsForCall, struct {
		arg1 api.InstanceType
	}{arg1})
	stub := fake.GetInstancesStub
	fakeReturns := fake.getInstancesReturns
	fake.recordInvocation("GetInstances", []interface{}{arg1})
	fake.getInstancesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) GetInstancesCallCount() int {
	fake.getInstancesMutex.RLock()
	defer fake.getInstancesMutex.RUnlock()
	return len(fake.getInstancesArgsForCall)
}

func (fake *FakeIncusAPI) GetInstancesCalls(stub func(api.InstanceType) ([]api.Instance, error)) {
	fake.getInstancesMutex.Lock()
	defer fake.getInstancesMutex.Unlock()
	fake.GetInstancesStub = stub
}

func (fake *FakeIncusAPI) GetInstancesArgsForCall(i int) api.InstanceType {
	fake.getInstancesMutex.RLock()
	defer fake.getInstancesMutex.RUnlock()
	argsForCall := fake.getInstancesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetInstancesReturns(result1 []api.Instance, result2 error) {
	fake.getInstancesMutex.Lock()
	defer fake.getInstancesMutex.Unlock()
	fake.GetInstancesStub = nil
	fake.getInstancesReturns = struct {
		result1 []api.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetInstancesReturnsOnCall(i int, result1 []api.Instance, result2 error) {
	fake.getInstancesMutex.Lock()
	defer fake.getInstancesMutex.Unlock()
	fake.GetInstancesStub = nil
	if fake.getInstancesReturnsOnCall == nil {
		fake.getInstancesReturnsOnCall = make(map[int]struct {
			result1 []api.Instance
			result2 error
		})
	}
	fake.getInstancesReturnsOnCall[i] = struct {
		result1 []api.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetNetwork(arg1 string) (*api.Network, string, error) {
	fake.getNetworkMutex.Lock()
	ret, specificReturn := fake.getNetworkReturnsOnCall[len(fake.getNetworkArgsForCall)]
	fake.getNetworkArgsForCall = append(fake.getNetworkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNetworkStub
	fakeReturns := fake.getNetworkReturns
	fake.recordInvocation("GetNetwork", []interface{}{arg1})
	fake.getNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetNetworkCallCount() int {
	fake.getNetworkMutex.RLock()
	defer fake.getNetworkMutex.RUnlock()
	return len(fake.getNetworkArgsForCall)
}

func (fake *FakeIncusAPI) GetNetworkCalls(stub func(string) (*api.Network, string, error)) {
	fake.getNetworkMutex.Lock()
	defer fake.getNetworkMutex.Unlock()
	fake.GetNetworkStub = stub
}

func (fake *FakeIncusAPI) GetNetworkArgsForCall(i int) string {
	fake.getNetworkMutex.RLock()
	defer fake.getNetworkMutex.RUnlock()
	argsForCall := fake.getNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetNetworkReturns(result1 *api.Network, result2 string, result3 error) {
	fake.getNetworkMutex.Lock()
	defer fake.getNetworkMutex.Unlock()
	fake.GetNetworkStub = nil
	fake.getNetworkReturns = struct {
		result1 *api.Network
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetNetworkReturnsOnCall(i int, result1 *api.Network, result2 string, result3 error) {
	fake.getNetworkMutex.Lock()
	defer fake.getNetworkMutex.Unlock()
	fake.GetNetworkStub = nil
	if fake.getNetworkReturnsOnCall == nil {
		fake.getNetworkReturnsOnCall = make(map[int]struct {
			result1 *api.Network
			result2 string
			result3 error
		})
	}
	fake.getNetworkReturnsOnCall[i] = struct {
		result1 *api.Network
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetNetworks() ([]api.Network, error) {
	fake.getNetworksMutex.Lock()
	ret, specificReturn := fake.getNetworksReturnsOnCall[len(fake.getNetworksArgsForCall)]
	fake.getNetworksArgsForCall = append(fake.getNetworksArgsForCall, struct {
	}{})
	stub := fake.GetNetworksStub
	fakeReturns := fake.getNetworksReturns
	fake.recordInvocation("GetNetworks", []interface{}{})
	fake.getNetworksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) GetNetworksCallCount() int {
	fake.getNetworksMutex.RLock()
	defer fake.getNetworksMutex.RUnlock()
	return len(fake.getNetworksArgsForCall)
}

func (fake *FakeIncusAPI) GetNetworksCalls(stub func() ([]api.Network, error)) {
	fake.getNetworksMutex.Lock()
	defer fake.getNetworksMutex.Unlock()
	fake.GetNetworksStub = stub
}

func (fake *FakeIncusAPI) GetNetworksReturns(result1 []api.Network, result2 error) {
	fake.getNetworksMutex.Lock()
	defer fake.getNetworksMutex.Unlock()
	fake.GetNetworksStub = nil
	fake.getNetworksReturns = struct {
		result1 []api.Network
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetNetworksReturnsOnCall(i int, result1 []api.Network, result2 error) {
	fake.getNetworksMutex.Lock()
	defer fake.getNetworksMutex.Unlock()
	fake.GetNetworksStub = nil
	if fake.getNetworksReturnsOnCall == nil {
		fake.getNetworksReturnsOnCall = make(map[int]struct {
			result1 []api.Network
			result2 error
		})
	}
	fake.getNetworksReturnsOnCall[i] = struct {
		result1 []api.Network
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetProfile(arg1 string) (*api.Profile, string, error) {
	fake.getProfileMutex.Lock()
	ret, specificReturn := fake.getProfileReturnsOnCall[len(fake.getProfileArgsForCall)]
	fake.getProfileArgsForCall = append(fake.getProfileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetProfileStub
	fakeReturns := fake.getProfileReturns
	fake.recordInvocation("GetProfile", []interface{}{arg1})
	fake.getProfileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetProfileCallCount() int {
	fake.getProfileMutex.RLock()
	defer fake.getProfileMutex.RUnlock()
	return len(fake.getProfileArgsForCall)
}

func (fake *FakeIncusAPI) GetProfileCalls(stub func(string) (*api.Profile, string, error)) {
	fake.getProfileMutex.Lock()
	defer fake.getProfileMutex.Unlock()
	fake.GetProfileStub = stub
}

func (fake *FakeIncusAPI) GetProfileArgsForCall(i int) string {
	fake.getProfileMutex.RLock()
	defer fake.getProfileMutex.RUnlock()
	argsForCall := fake.getProfileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetProfileReturns(result1 *api.Profile, result2 string, result3 error) {
	fake.getProfileMutex.Lock()
	defer fake.getProfileMutex.Unlock()
	fake.GetProfileStub = nil
	fake.getProfileReturns = struct {
		result1 *api.Profile
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetProfileReturnsOnCall(i int, result1 *api.Profile, result2 string, result3 error) {
	fake.getProfileMutex.Lock()
	defer fake.getProfileMutex.Unlock()
	fake.GetProfileStub = nil
	if fake.getProfileReturnsOnCall == nil {
		fake.getProfileReturnsOnCall = make(map[int]struct {
			result1 *api.Profile
			result2 string
			result3 error
		})
	}
	fake.getProfileReturnsOnCall[i] = struct {
		result1 *api.Profile
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetServer() (*api.Server, string, error) {
	fake.getServerMutex.Lock()
	ret, specificReturn := fake.getServerReturnsOnCall[len(fake.getServerArgsForCall)]
	fake.getServerArgsForCall = append(fake.getServerArgsForCall, struct {
	}{})
	stub := fake.GetServerStub
	fakeReturns := fake.getServerReturns
	fake.recordInvocation("GetServer", []interface{}{})
	fake.getServerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetServerCallCount() int {
	fake.getServerMutex.RLock()
	defer fake.getServerMutex.RUnlock()
	return len(fake.getServerArgsForCall)
}

func (fake *FakeIncusAPI) GetServerCalls(stub func() (*api.Server, string, error)) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = stub
}

func (fake *FakeIncusAPI) GetServerReturns(result1 *api.Server, result2 string, result3 error) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = nil
	fake.getServerReturns = struct {
		result1 *api.Server
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetServerReturnsOnCall(i int, result1 *api.Server, result2 string, result3 error) {
	fake.getServerMutex.Lock()
	defer fake.getServerMutex.Unlock()
	fake.GetServerStub = nil
	if fake.getServerReturnsOnCall == nil {
		fake.getServerReturnsOnCall = make(map[int]struct {
			result1 *api.Server
			result2 string
			result3 error
		})
	}
	fake.getServerReturnsOnCall[i] = struct {
		result1 *api.Server
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetStoragePool(arg1 string) (*api.StoragePool, string, error) {
	fake.getStoragePoolMutex.Lock()
	ret, specificReturn := fake.getStoragePoolReturnsOnCall[len(fake.getStoragePoolArgsForCall)]
	fake.getStoragePoolArgsForCall = append(fake.getStoragePoolArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStoragePoolStub
	fakeReturns := fake.getStoragePoolReturns
	fake.recordInvocation("GetStoragePool", []interface{}{arg1})
	fake.getStoragePoolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIncusAPI) GetStoragePoolCallCount() int {
	fake.getStoragePoolMutex.RLock()
	defer fake.getStoragePoolMutex.RUnlock()
	return len(fake.getStoragePoolArgsForCall)
}

func (fake *FakeIncusAPI) GetStoragePoolCalls(stub func(string) (*api.StoragePool, string, error)) {
	fake.getStoragePoolMutex.Lock()
	defer fake.getStoragePoolMutex.Unlock()
	fake.GetStoragePoolStub = stub
}

func (fake *FakeIncusAPI) GetStoragePoolArgsForCall(i int) string {
	fake.getStoragePoolMutex.RLock()
	defer fake.getStoragePoolMutex.RUnlock()
	argsForCall := fake.getStoragePoolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) GetStoragePoolReturns(result1 *api.StoragePool, result2 string, result3 error) {
	fake.getStoragePoolMutex.Lock()
	defer fake.getStoragePoolMutex.Unlock()
	fake.GetStoragePoolStub = nil
	fake.getStoragePoolReturns = struct {
		result1 *api.StoragePool
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetStoragePoolReturnsOnCall(i int, result1 *api.StoragePool, result2 string, result3 error) {
	fake.getStoragePoolMutex.Lock()
	defer fake.getStoragePoolMutex.Unlock()
	fake.GetStoragePoolStub = nil
	if fake.getStoragePoolReturnsOnCall == nil {
		fake.getStoragePoolReturnsOnCall = make(map[int]struct {
			result1 *api.StoragePool
			result2 string
			result3 error
		})
	}
	fake.getStoragePoolReturnsOnCall[i] = struct {
		result1 *api.StoragePool
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIncusAPI) GetStoragePools() ([]api.StoragePool, error) {
	fake.getStoragePoolsMutex.Lock()
	ret, specificReturn := fake.getStoragePoolsReturnsOnCall[len(fake.getStoragePoolsArgsForCall)]
	fake.getStoragePoolsArgsForCall = append(fake.getStoragePoolsArgsForCall, struct {
	}{})
	stub := fake.GetStoragePoolsStub
	fakeReturns := fake.getStoragePoolsReturns
	fake.recordInvocation("GetStoragePools", []interface{}{})
	fake.getStoragePoolsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) GetStoragePoolsCallCount() int {
	fake.getStoragePoolsMutex.RLock()
	defer fake.getStoragePoolsMutex.RUnlock()
	return len(fake.getStoragePoolsArgsForCall)
}

func (fake *FakeIncusAPI) GetStoragePoolsCalls(stub func() ([]api.StoragePool, error)) {
	fake.getStoragePoolsMutex.Lock()
	defer fake.getStoragePoolsMutex.Unlock()
	fake.GetStoragePoolsStub = stub
}

func (fake *FakeIncusAPI) GetStoragePoolsReturns(result1 []api.StoragePool, result2 error) {
	fake.getStoragePoolsMutex.Lock()
	defer fake.getStoragePoolsMutex.Unlock()
	fake.GetStoragePoolsStub = nil
	fake.getStoragePoolsReturns = struct {
		result1 []api.StoragePool
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) GetStoragePoolsReturnsOnCall(i int, result1 []api.StoragePool, result2 error) {
	fake.getStoragePoolsMutex.Lock()
	defer fake.getStoragePoolsMutex.Unlock()
	fake.GetStoragePoolsStub = nil
	if fake.getStoragePoolsReturnsOnCall == nil {
		fake.getStoragePoolsReturnsOnCall = make(map[int]struct {
			result1 []api.StoragePool
			result2 error
		})
	}
	fake.getStoragePoolsReturnsOnCall[i] = struct {
		result1 []api.StoragePool
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) UpdateInstanceState(arg1 string, arg2 api.InstanceStatePut, arg3 string) (incusa.Operation, error) {
	fake.updateInstanceStateMutex.Lock()
	ret, specificReturn := fake.updateInstanceStateReturnsOnCall[len(fake.updateInstanceStateArgsForCall)]
	fake.updateInstanceStateArgsForCall = append(fake.updateInstanceStateArgsForCall, struct {
		arg1 string
		arg2 api.InstanceStatePut
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateInstanceStateStub
	fakeReturns := fake.updateInstanceStateReturns
	fake.recordInvocation("UpdateInstanceState", []interface{}{arg1, arg2, arg3})
	fake.updateInstanceStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIncusAPI) UpdateInstanceStateCallCount() int {
	fake.updateInstanceStateMutex.RLock()
	defer fake.updateInstanceStateMutex.RUnlock()
	return len(fake.updateInstanceStateArgsForCall)
}

func (fake *FakeIncusAPI) UpdateInstanceStateCalls(stub func(string, api.InstanceStatePut, string) (incusa.Operation, error)) {
	fake.updateInstanceStateMutex.Lock()
	defer fake.updateInstanceStateMutex.Unlock()
	fake.UpdateInstanceStateStub = stub
}

func (fake *FakeIncusAPI) UpdateInstanceStateArgsForCall(i int) (string, api.InstanceStatePut, string) {
	fake.updateInstanceStateMutex.RLock()
	defer fake.updateInstanceStateMutex.RUnlock()
	argsForCall := fake.updateInstanceStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIncusAPI) UpdateInstanceStateReturns(result1 incusa.Operation, result2 error) {
	fake.updateInstanceStateMutex.Lock()
	defer fake.updateInstanceStateMutex.Unlock()
	fake.UpdateInstanceStateStub = nil
	fake.updateInstanceStateReturns = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) UpdateInstanceStateReturnsOnCall(i int, result1 incusa.Operation, result2 error) {
	fake.updateInstanceStateMutex.Lock()
	defer fake.updateInstanceStateMutex.Unlock()
	fake.UpdateInstanceStateStub = nil
	if fake.updateInstanceStateReturnsOnCall == nil {
		fake.updateInstanceStateReturnsOnCall = make(map[int]struct {
			result1 incusa.Operation
			result2 error
		})
	}
	fake.updateInstanceStateReturnsOnCall[i] = struct {
		result1 incusa.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeIncusAPI) UseProject(arg1 string) incusa.InstanceServer {
	fake.useProjectMutex.Lock()
	ret, specificReturn := fake.useProjectReturnsOnCall[len(fake.useProjectArgsForCall)]
	fake.useProjectArgsForCall = append(fake.useProjectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UseProjectStub
	fakeReturns := fake.useProjectReturns
	fake.recordInvocation("UseProject", []interface{}{arg1})
	fake.useProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) UseProjectCallCount() int {
	fake.useProjectMutex.RLock()
	defer fake.useProjectMutex.RUnlock()
	return len(fake.useProjectArgsForCall)
}

func (fake *FakeIncusAPI) UseProjectCalls(stub func(string) incusa.InstanceServer) {
	fake.useProjectMutex.Lock()
	defer fake.useProjectMutex.Unlock()
	fake.UseProjectStub = stub
}

func (fake *FakeIncusAPI) UseProjectArgsForCall(i int) string {
	fake.useProjectMutex.RLock()
	defer fake.useProjectMutex.RUnlock()
	argsForCall := fake.useProjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) UseProjectReturns(result1 incusa.InstanceServer) {
	fake.useProjectMutex.Lock()
	defer fake.useProjectMutex.Unlock()
	fake.UseProjectStub = nil
	fake.useProjectReturns = struct {
		result1 incusa.InstanceServer
	}{result1}
}

func (fake *FakeIncusAPI) UseProjectReturnsOnCall(i int, result1 incusa.InstanceServer) {
	fake.useProjectMutex.Lock()
	defer fake.useProjectMutex.Unlock()
	fake.UseProjectStub = nil
	if fake.useProjectReturnsOnCall == nil {
		fake.useProjectReturnsOnCall = make(map[int]struct {
			result1 incusa.InstanceServer
		})
	}
	fake.useProjectReturnsOnCall[i] = struct {
		result1 incusa.InstanceServer
	}{result1}
}

func (fake *FakeIncusAPI) UseTarget(arg1 string) incusa.InstanceServer {
	fake.useTargetMutex.Lock()
	ret, specificReturn := fake.useTargetReturnsOnCall[len(fake.useTargetArgsForCall)]
	fake.useTargetArgsForCall = append(fake.useTargetArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UseTargetStub
	fakeReturns := fake.useTargetReturns
	fake.recordInvocation("UseTarget", []interface{}{arg1})
	fake.useTargetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIncusAPI) UseTargetCallCount() int {
	fake.useTargetMutex.RLock()
	defer fake.useTargetMutex.RUnlock()
	return len(fake.useTargetArgsForCall)
}

func (fake *FakeIncusAPI) UseTargetCalls(stub func(string) incusa.InstanceServer) {
	fake.useTargetMutex.Lock()
	defer fake.useTargetMutex.Unlock()
	fake.UseTargetStub = stub
}

func (fake *FakeIncusAPI) UseTargetArgsForCall(i int) string {
	fake.useTargetMutex.RLock()
	defer fake.useTargetMutex.RUnlock()
	argsForCall := fake.useTargetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIncusAPI) UseTargetReturns(result1 incusa.InstanceServer) {
	fake.useTargetMutex.Lock()
	defer fake.useTargetMutex.Unlock()
	fake.UseTargetStub = nil
	fake.useTargetReturns = struct {
		result1 incusa.InstanceServer
	}{result1}
}

func (fake *FakeIncusAPI) UseTargetReturnsOnCall(i int, result1 incusa.InstanceServer) {
	fake.useTargetMutex.Lock()
	defer fake.useTargetMutex.Unlock()
	fake.UseTargetStub = nil
	if fake.useTargetReturnsOnCall == nil {
		fake.useTargetReturnsOnCall = make(map[int]struct {
			result1 incusa.InstanceServer
		})
	}
	fake.useTargetReturnsOnCall[i] = struct {
		result1 incusa.InstanceServer
	}{result1}
}

func (fake *FakeIncusAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIncusAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ incus.IncusAPI = new(FakeIncusAPI)
